# 모듈화 교훈 (Lessons Learned)

> 작성일: 2025-12-30  
> 문제: `page.tsx`가 2,747줄로 비대해진 원인 분석 및 개선 방안

## 🚨 현재 문제 상황

- **`page.tsx`**: 2,747줄 (목표 700±100줄 대비 3.9배)
- **`FailureLinkTab.tsx`**: 1,102줄 (목표 700±100줄 대비 1.6배)
- 모듈화를 권장했으나 실제로는 점진적으로 코드가 커짐

## 🔍 문제 발생 원인 분석

### 1. 점진적 기능 추가 과정에서의 부작용

#### 기능 추가 흐름
1. 초기 구조: 기본 탭 구조 및 상태 관리
2. 고장연결 기능 추가: `FailureLinkTab` 내부 로직 복잡화
3. 평가 탭 추가: `EvalTabRenderer` 내부에 여러 탭 로직 통합
4. 전체보기 기능: `all` 탭 로직을 `EvalTabRenderer` 내부에 추가
5. 마지막 행 병합: 기존 파일 내부에 로직 추가

#### 문제점
- **"일단 동작하게 만들고 나중에 리팩토링"** 접근
- 새로운 기능을 기존 파일에 추가하는 것이 더 빠르다고 판단
- 모듈화 비용(파일 분리, Props 전달 등)을 회피
- **즉각적인 기능 구현에 집중, 구조적 설계 부족**

### 2. 리팩토링 지연

#### 결정 요인
- **시간적 압박**: 기능 완성을 우선시
- **테스트 부담**: 모듈 분리 시 테스트 범위 확대 필요
- **위험 회피**: 동작하는 코드를 건드리는 것을 꺼림
- **코드프리즈 태그**: 특정 버전을 보존하려는 의도로 리팩토링 지연

#### 결과
- 리팩토링이 계속 미뤄짐
- 코드 복잡도가 기하급수적으로 증가
- 중복 코드가 누적됨

### 3. 구조적 설계 부재

#### 초기 설계 부족
- 파일 크기 기준(700±100줄)을 명확히 설정하지 않음
- 컴포넌트 분리 원칙을 사전에 정의하지 않음
- 모듈 경계를 명확히 하지 않음

#### 중복 로직 처리 미흡
- `failureLinks` 그룹핑 로직이 4곳에서 반복
- 마지막 행 병합 로직이 2곳에서 반복
- 공정명별 그룹핑 로직이 여러 곳에서 반복
- **"복사-붙여넣기" 방식으로 빠른 구현**

## 💡 교훈

### 1. 사전 설계의 중요성

#### 해야 할 것
- **파일 크기 제한을 엄격히 적용**: 700줄 초과 시 즉시 분리
- **컴포넌트 분리 원칙 사전 정의**: 
  - 단일 책임 원칙 (SRP)
  - 관심사의 분리 (SoC)
  - 재사용 가능한 단위
- **모듈 경계 명확히 정의**

#### 하지 말아야 할 것
- "일단 동작하게 만들고 나중에 리팩토링"
- "이번 한 번만 여기에 추가하고"
- "시간이 부족해서 일단 여기에"

### 2. 지속적인 리팩토링

#### 해야 할 것
- **기능 추가 시마다 구조 검토**
- **중복 코드 발견 즉시 추출**
- **파일 크기 모니터링 및 경고**

#### 하지 말아야 할 것
- "나중에 한꺼번에 리팩토링"
- "기능이 완성되면 리팩토링"
- "코드프리즈 때문에 리팩토링 못 함"

### 3. 모듈화 우선 접근

#### 해야 할 것
- **새 기능 추가 시 새로운 파일/컴포넌트로 시작**
- **공통 로직은 즉시 유틸리티로 추출**
- **컴포넌트는 작게 시작하고 필요시 확장**

#### 하지 말아야 할 것
- 기존 파일에 기능 추가 후 분리 계획
- "일단 여기에 넣고 나중에 옮기자"
- Props 전달 복잡도를 이유로 모듈화 회피

## 🎯 개선 방안

### 즉시 적용 (Going Forward)

1. **엄격한 파일 크기 제한**
   - 600줄 도달 시 경고
   - 700줄 초과 시 즉시 분리 의무화
   - 리뷰 시 파일 크기 체크

2. **컴포넌트 분리 체크리스트**
   ```
   새 기능 추가 전 확인:
   [ ] 목적이 명확한가? (단일 책임)
   [ ] 재사용 가능한가?
   [ ] 독립적으로 테스트 가능한가?
   [ ] 파일 크기가 700줄 이하인가?
   ```

3. **중복 코드 제로 정책**
   - 중복 발견 시 즉시 추출
   - 공통 로직은 유틸리티로 즉시 분리
   - "복사-붙여넣기" 금지

4. **정기적 코드 리뷰**
   - 주간 파일 크기 모니터링
   - 구조적 문제 조기 발견
   - 리팩토링 우선순위 설정

### 현재 상황 개선

1. **리팩토링 마스터 플랜 실행**
   - Step 1부터 순차적으로 진행
   - 각 Step 완료 후 검증
   - 파일 크기 목표 달성까지 지속

2. **기술 부채 정리**
   - 중복 코드 즉시 제거
   - 큰 파일 즉시 분리
   - 타입 안정성 개선

## 📊 비교: 이상 vs 현실

### 이상적인 접근 (처음부터 모듈화)

```
src/app/pfmea/worksheet/
├── page.tsx                      (~300줄) - 라우팅 및 레이아웃만
├── components/
│   ├── TabMenu.tsx              (~150줄)
│   ├── EvalStructureTab.tsx     (~200줄)
│   ├── EvalFunctionTab.tsx      (~200줄)
│   ├── EvalFailureTab.tsx       (~200줄)
│   └── AllViewTab.tsx           (~500줄)
├── utils/
│   ├── failure-link-grouping.ts (~150줄)
│   ├── row-merge-logic.ts       (~100줄)
│   └── process-grouping.ts      (~80줄)
└── tabs/
    └── failure/
        ├── FailureLinkTab.tsx   (~400줄)
        ├── FailureLinkDiagram.tsx (~300줄)
        └── FailureLinkResult.tsx (~350줄)
```

**장점:**
- 각 파일이 명확한 목적
- 재사용 가능
- 테스트 용이
- 유지보수 쉬움

### 현실 (점진적 누적)

```
src/app/pfmea/worksheet/
├── page.tsx                      (2,747줄) ❌
│   ├── TabMenu 컴포넌트          (~200줄)
│   ├── EvalTabRenderer          (~600줄)
│   │   ├── eval-structure       (~150줄)
│   │   ├── eval-function        (~150줄)
│   │   ├── eval-failure         (~150줄)
│   │   └── all                  (~450줄)
│   └── 이벤트 핸들러             (~500줄)
└── tabs/failure/
    └── FailureLinkTab.tsx       (1,102줄) ❌
        ├── 다이어그램 뷰         (~400줄)
        └── 결과 테이블 뷰        (~500줄)
```

**문제점:**
- 파일 크기 과다
- 중복 코드 누적
- 테스트 어려움
- 유지보수 어려움

## ✅ 앞으로의 약속

### 개발 원칙

1. **"작게 시작, 명확하게 분리"**
   - 새 기능은 새 파일로 시작
   - 목적이 다르면 컴포넌트 분리
   - 파일 크기 700줄 초과 금지

2. **"중복은 즉시 제거"**
   - 복사-붙여넣기 금지
   - 공통 로직은 즉시 추출
   - 유틸리티 함수 적극 활용

3. **"지속적인 리팩토링"**
   - 기능 추가 시 구조 검토
   - 정기적 코드 리뷰
   - 기술 부채 즉시 정리

4. **"사전 설계 우선"**
   - 기능 추가 전 구조 검토
   - 모듈 경계 명확히 정의
   - 재사용성 고려

## 🔄 실행 계획

### 즉시 실행
1. ✅ 리팩토링 마스터 플랜 작성 완료
2. ⏳ Step 1: 공통 유틸리티 함수 추출 (진행 예정)
3. ⏳ Step 2-6: 순차적 리팩토링

### 지속적 개선
1. 파일 크기 모니터링 스크립트 추가 (선택사항)
2. 코드 리뷰 체크리스트 적용
3. 개발 가이드라인 문서화

---

**결론**: 모듈화를 권장했으나 실행 단계에서 점진적 누적으로 인해 코드가 비대해졌습니다. 이제 리팩토링을 통해 개선하고, 앞으로는 엄격한 원칙을 적용하여 같은 문제가 발생하지 않도록 하겠습니다.

