/**
 * @file route.ts
 * @description FMEA ë°ì´í„° ì €ìž¥/ë¡œë“œ API ë¼ìš°íŠ¸
 * 
 * â˜…â˜…â˜… ê·¼ë³¸ì ì¸ í•´ê²°ì±…: ë ˆê±°ì‹œ ë°ì´í„° = Single Source of Truth â˜…â˜…â˜…
 * - ì €ìž¥ ì‹œ: ë ˆê±°ì‹œ ë°ì´í„°ë¥¼ FmeaLegacyData í…Œì´ë¸”ì— JSONìœ¼ë¡œ ì§ì ‘ ì €ìž¥
 * - ë¡œë“œ ì‹œ: FmeaLegacyDataì—ì„œ ì§ì ‘ ê°€ì ¸ì˜¤ê³ , ì›ìžì„± DBëŠ” PFD/CP/WS/PM ì—°ë™ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©
 * - ì´ë¥¼ í†µí•´ ì›ìžì„± DB â†” ë ˆê±°ì‹œ ë³€í™˜ ê³¼ì •ì—ì„œì˜ ë°ì´í„° ì†ì‹¤ ë¬¸ì œ í•´ê²°
 * 
 * POST /api/fmea - FMEA ë°ì´í„° ì €ìž¥
 * GET /api/fmea?fmeaId=xxx - FMEA ë°ì´í„° ë¡œë“œ
 */

import { NextRequest, NextResponse } from 'next/server';
import type { FMEAWorksheetDB } from '@/app/pfmea/worksheet/schema';
import { getBaseDatabaseUrl, getPrisma, getPrismaForSchema } from '@/lib/prisma';
import { upsertActiveMasterFromWorksheetTx } from '@/app/api/pfmea/master/sync';
import { ensureProjectSchemaReady, getProjectSchemaName } from '@/lib/project-schema';
import { Pool } from 'pg';

// ë ˆê±°ì‹œ ë°ì´í„° ìŠ¤í‚¤ë§ˆ ë²„ì „
const LEGACY_DATA_VERSION = '1.0.0';

// âœ… "(ìžë™ìƒì„±)" í”Œë ˆì´ìŠ¤í™€ë” ë°ì´í„° í•„í„°ë§ í•¨ìˆ˜
function isAutoGeneratedPlaceholder(name: string | undefined | null): boolean {
  if (!name) return false;
  const str = String(name);
  return str.includes('ìžë™ìƒì„±') || str.includes('(ìžë™ìƒì„±)');
}

// âœ… ë ˆê±°ì‹œ ë°ì´í„°ì—ì„œ "(ìžë™ìƒì„±)" í•­ëª© ì™„ì „ ì œê±°
function cleanAutoGeneratedData(legacy: any): any {
  if (!legacy) return legacy;
  
  const cleaned = JSON.parse(JSON.stringify(legacy));
  let removedCount = 0;
  
  // l2 ë°°ì—´ ìˆœíšŒ
  if (Array.isArray(cleaned.l2)) {
    cleaned.l2 = cleaned.l2.map((proc: any) => {
      // l3 (ìž‘ì—…ìš”ì†Œ) ë‚´ functions ì •ë¦¬
      if (Array.isArray(proc.l3)) {
        proc.l3 = proc.l3.map((we: any) => {
          if (Array.isArray(we.functions)) {
            const originalCount = we.functions.length;
            we.functions = we.functions.filter((f: any) => !isAutoGeneratedPlaceholder(f.name));
            removedCount += originalCount - we.functions.length;
          }
          return we;
        });
      }
      
      // functions (ë©”ì¸ê³µì •ê¸°ëŠ¥) ì •ë¦¬
      if (Array.isArray(proc.functions)) {
        const originalCount = proc.functions.length;
        proc.functions = proc.functions.filter((f: any) => !isAutoGeneratedPlaceholder(f.name));
        removedCount += originalCount - proc.functions.length;
      }
      
      // failureModes ì •ë¦¬
      if (Array.isArray(proc.failureModes)) {
        const originalCount = proc.failureModes.length;
        proc.failureModes = proc.failureModes.filter((m: any) => !isAutoGeneratedPlaceholder(m.name));
        removedCount += originalCount - proc.failureModes.length;
      }
      
      // failureCauses ì •ë¦¬
      if (Array.isArray(proc.failureCauses)) {
        const originalCount = proc.failureCauses.length;
        proc.failureCauses = proc.failureCauses.filter((c: any) => !isAutoGeneratedPlaceholder(c.name));
        removedCount += originalCount - proc.failureCauses.length;
      }
      
      return proc;
    });
  }
  
  // l1.types ë‚´ functions ì •ë¦¬
  if (cleaned.l1 && Array.isArray(cleaned.l1.types)) {
    cleaned.l1.types = cleaned.l1.types.map((type: any) => {
      if (Array.isArray(type.functions)) {
        const originalCount = type.functions.length;
        type.functions = type.functions.filter((f: any) => !isAutoGeneratedPlaceholder(f.name));
        removedCount += originalCount - type.functions.length;
      }
      return type;
    });
  }
  
  // l1.failureScopes ì •ë¦¬
  if (cleaned.l1 && Array.isArray(cleaned.l1.failureScopes)) {
    const originalCount = cleaned.l1.failureScopes.length;
    cleaned.l1.failureScopes = cleaned.l1.failureScopes.filter((s: any) => !isAutoGeneratedPlaceholder(s.effect));
    removedCount += originalCount - cleaned.l1.failureScopes.length;
  }
  
  if (removedCount > 0) {
    console.log(`[API] âœ… "(ìžë™ìƒì„±)" ë°ì´í„° ${removedCount}ê±´ ì œê±°ë¨`);
  }
  
  return cleaned;
}

function computeLegacyCompletenessScore(legacy: any): number {
  if (!legacy) return 0;
  let score = 0;
  const l1Name = String(legacy?.l1?.name || '').trim();
  if (l1Name) score += 50;

  const l2 = Array.isArray(legacy?.l2) ? legacy.l2 : [];
  const meaningfulProcs = l2.filter((p: any) => String(p?.name || p?.no || '').trim());
  score += meaningfulProcs.length * 20;

  const l3Count = l2.reduce((acc: number, p: any) => acc + (Array.isArray(p?.l3) ? p.l3.length : 0), 0);
  score += l3Count * 5;

  const fmCount = l2.reduce((acc: number, p: any) => acc + (Array.isArray(p?.failureModes) ? p.failureModes.length : 0), 0);
  const fcCount = l2.reduce((acc: number, p: any) => acc + (Array.isArray(p?.failureCauses) ? p.failureCauses.length : 0), 0);
  score += (fmCount + fcCount) * 2;

  const feCount = Array.isArray(legacy?.l1?.failureScopes) ? legacy.l1.failureScopes.length : 0;
  score += feCount * 2;

  return score;
}

// âœ… PrismaëŠ” Node.js ëŸ°íƒ€ìž„ì—ì„œë§Œ ì•ˆì •ì ìœ¼ë¡œ ë™ìž‘ (edge/browser ë²ˆë“¤ ë°©ì§€)
export const runtime = 'nodejs';

// íŠ¸ëžœìž­ì…˜ íƒ€ìž„ì•„ì›ƒ (30ì´ˆ)
const TRANSACTION_TIMEOUT = 30000;

/**
 * FMEA ë°ì´í„° ì €ìž¥ (ë°°ì¹˜ ì²˜ë¦¬ ìµœì í™”)
 */
export async function POST(request: NextRequest) {
  try {
    const baseUrl = getBaseDatabaseUrl();
    if (!baseUrl) {
      console.warn('[API] Prisma ë¯¸í™œì„±(null), ì €ìž¥ ìŠ¤í‚µ (localStorage í´ë°± ì‚¬ìš©)');
      return NextResponse.json(
        { 
          success: false,
          message: 'DATABASE_URL not configured, using localStorage fallback', 
          fmeaId: null,
          fallback: true 
        },
        { status: 200 }
      );
    }

    const requestBody = await request.json();
    const db: FMEAWorksheetDB = requestBody;
    const legacyData = requestBody.legacyData; // âœ… ë ˆê±°ì‹œ ë°ì´í„° (Single Source of Truth)
    const forceOverwrite = Boolean(requestBody.forceOverwrite); // âœ… ì„œë²„ ê°€ë“œ ìš°íšŒ (ë””ë²„ê¹…/ê´€ë¦¬ìžìš©)
    
    console.log(`[API] FMEA ì €ìž¥ ì‹œìž‘: ID=${db.fmeaId}, ìŠ¤í‚¤ë§ˆ íƒ€ê²ŸíŒ… ì¤€ë¹„`);
    console.log(`[API] ðŸ“Š ì „ì†¡ë°›ì€ ë°ì´í„°:`, {
      fmeaId: db.fmeaId,
      hasL1Structure: !!db.l1Structure,
      l1StructureName: db.l1Structure?.name,
      l2StructuresCount: db.l2Structures?.length || 0,
      l3StructuresCount: db.l3Structures?.length || 0,
      l1FunctionsCount: db.l1Functions?.length || 0,
      l2FunctionsCount: db.l2Functions?.length || 0,
      l3FunctionsCount: db.l3Functions?.length || 0,
      // â˜…â˜…â˜… ê³ ìž¥ ë°ì´í„° ê°œìˆ˜ ë¡œê¹… â˜…â˜…â˜…
      failureEffectsCount: db.failureEffects?.length || 0,
      failureModesCount: db.failureModes?.length || 0,
      failureCausesCount: db.failureCauses?.length || 0,
      failureLinksCount: db.failureLinks?.length || 0,
      riskAnalysesCount: db.riskAnalyses?.length || 0,  // â˜… ì¶”ê°€
      hasLegacyData: !!legacyData,
      legacyL1Name: legacyData?.l1?.name,
      legacyL2Count: legacyData?.l2?.length || 0,
      legacyRiskDataCount: Object.keys(legacyData?.riskData || {}).length,
    });
    
    // â˜…â˜…â˜… ê³ ìž¥ ë°ì´í„° ìƒì„¸ ë¡œê¹… â˜…â˜…â˜…
    if (db.failureModes?.length > 0) {
      console.log('[API] ðŸ“‹ FM ìƒ˜í”Œ:', db.failureModes.slice(0, 2).map(fm => ({
        id: fm.id,
        mode: fm.mode?.substring(0, 20),
        l2FuncId: fm.l2FuncId,
        l2StructId: fm.l2StructId,
      })));
    }
    if (db.failureCauses?.length > 0) {
      console.log('[API] ðŸ“‹ FC ìƒ˜í”Œ:', db.failureCauses.slice(0, 2).map(fc => ({
        id: fc.id,
        cause: fc.cause?.substring(0, 20),
        l3FuncId: fc.l3FuncId,
        l3StructId: fc.l3StructId,
      })));
    }
    if (db.failureEffects?.length > 0) {
      console.log('[API] ðŸ“‹ FE ìƒ˜í”Œ:', db.failureEffects.slice(0, 2).map(fe => ({
        id: fe.id,
        effect: fe.effect?.substring(0, 20),
        l1FuncId: fe.l1FuncId,
      })));
    }
    
    // âœ… FMEA IDëŠ” í•­ìƒ ì†Œë¬¸ìžë¡œ ì •ê·œí™” (DB ì¼ê´€ì„± ë³´ìž¥)
    // â˜… ì›ë³¸ fmeaId ë³´ì¡´ (DELETE ì‹œ ëŒ€ì†Œë¬¸ìž ë¬´ê´€ ì‚­ì œìš©)
    const originalFmeaId = db.fmeaId;
    if (db.fmeaId) {
      db.fmeaId = db.fmeaId.toLowerCase(); // â˜… ì†Œë¬¸ìžë¡œ ì •ê·œí™”
    }
    const normalizedFmeaId = db.fmeaId;
    
    if (!db.fmeaId) {
      console.error('[API] FMEA IDê°€ ì—†ìŠµë‹ˆë‹¤.');
      return NextResponse.json(
        { error: 'FMEA ID is required' },
        { status: 400 }
      );
    }

    // âœ… í”„ë¡œì íŠ¸ë³„ DB(ìŠ¤í‚¤ë§ˆ) ê·œì¹™: fmeaId ê¸°ì¤€ìœ¼ë¡œ ìŠ¤í‚¤ë§ˆ ìžë™ ìƒì„±/ì´ˆê¸°í™” í›„ ê·¸ ìŠ¤í‚¤ë§ˆì— ì €ìž¥
    const schema = getProjectSchemaName(db.fmeaId);
    console.log(`[API] í”„ë¡œì íŠ¸ ìŠ¤í‚¤ë§ˆ: ${schema}`);
    await ensureProjectSchemaReady({ baseDatabaseUrl: baseUrl, schema });
    const prisma = getPrismaForSchema(schema);
    if (!prisma) {
      console.warn('[API] Prisma ë¯¸í™œì„±(null), ì €ìž¥ ìŠ¤í‚µ (localStorage í´ë°± ì‚¬ìš©)');
      return NextResponse.json(
        { 
          success: false,
          message: 'DATABASE_URL not configured, using localStorage fallback', 
          fmeaId: null,
          fallback: true 
        },
        { status: 200 }
      );
    }

    // âœ… DB ì—°ê²° í…ŒìŠ¤íŠ¸ (ìŠ¤í‚¤ë§ˆë³„ Prisma)
    try {
      await prisma.$queryRaw`SELECT 1`;
    } catch (connError: any) {
      console.error('[API] DB ì—°ê²° ì‹¤íŒ¨:', connError);
      return NextResponse.json(
        { 
          success: false,
          error: 'Database connection failed',
          message: 'ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. localStorageë¡œ í´ë°±ë©ë‹ˆë‹¤.',
          details: connError.message,
          fallback: true
        },
        { status: 200 }
      );
    }

    const incomingLegacyScore = legacyData ? computeLegacyCompletenessScore(legacyData) : 0;

    // âœ… ì„œë²„-ì‚¬ì´ë“œ ë³´í˜¸ ê°€ë“œ:
    // - ê¸°ì¡´ ë ˆê±°ì‹œ ë°ì´í„°ê°€ ì¶©ë¶„ížˆ í’ë¶€í•œë°, ë“¤ì–´ì˜¨ legacyDataê°€ ë¹ˆ/ì €í’ˆì§ˆì´ë©´ ë®ì–´ì“°ê¸° ì°¨ë‹¨
    // - ìžë™ì €ìž¥ íƒ€ì´ë° ì´ìŠˆë¡œ â€œë¹ˆ ìƒíƒœ ì €ìž¥â€ì´ ë°œìƒí•´ë„ DBê°€ ë§ê°€ì§€ì§€ ì•Šë„ë¡ ë³´í˜¸
    if (!forceOverwrite && legacyData) {
      try {
        const existing = await prisma.fmeaLegacyData.findUnique({ where: { fmeaId: db.fmeaId } });
        if (existing?.data) {
          const incomingScore = computeLegacyCompletenessScore(legacyData);
          const existingScore = computeLegacyCompletenessScore(existing.data);
          const incomingL2Count = Array.isArray((legacyData as any)?.l2) ? (legacyData as any).l2.length : 0;
          const existingL2Count = Array.isArray((existing.data as any)?.l2) ? (existing.data as any).l2.length : 0;

          const looksLikeWipe =
            (incomingScore === 0 && existingScore >= 50) ||
            (incomingL2Count === 0 && existingL2Count > 0) ||
            (incomingScore < existingScore && incomingScore <= 20);

          if (looksLikeWipe) {
            console.warn('[API] ðŸ›¡ï¸ ë®ì–´ì“°ê¸° ì°¨ë‹¨: ê¸°ì¡´ ë ˆê±°ì‹œê°€ ë” í’ë¶€í•¨', {
              fmeaId: db.fmeaId,
              incomingScore,
              existingScore,
              incomingL2Count,
              existingL2Count,
            });
            // 200ìœ¼ë¡œ ë°˜í™˜í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ê°€ ì—ëŸ¬ë¡œ ê°„ì£¼í•˜ì§€ ì•Šê²Œ í•˜ê³ , ê¸°ì¡´ DB ë°ì´í„° ë³´ì¡´
            return NextResponse.json(
              {
                success: true,
                preventedOverwrite: true,
                message: 'Prevented overwriting existing legacy data with an empty/low-quality payload.',
                incomingScore,
                existingScore,
              },
              { status: 200 }
            );
          }
        }
      } catch (e: any) {
        // í…Œì´ë¸” ì—†ê±°ë‚˜ ì ‘ê·¼ ì‹¤íŒ¨ ì‹œ ê°€ë“œ ìŠ¤í‚µ (í•˜ìœ„ í˜¸í™˜)
        if (e?.code !== 'P2021') {
          console.warn('[API] ë ˆê±°ì‹œ ë®ì–´ì“°ê¸° ê°€ë“œ ì˜¤ë¥˜(ë¬´ì‹œ):', e.message);
        }
      }
    }

    // íŠ¸ëžœìž­ì…˜ìœ¼ë¡œ ëª¨ë“  ë°ì´í„° ì €ìž¥ (ë°°ì¹˜ ì²˜ë¦¬)
    await prisma.$transaction(async (tx: any) => {
      // âœ… ê°•ë ¥í•œ ìŠ¤í‚¤ë§ˆ ê°•ì œ: íŠ¸ëžœìž­ì…˜ ì‹œìž‘ ì‹œ search_path ëª…ì‹œì  ì„¤ì •
      console.log(`[API] íŠ¸ëžœìž­ì…˜ ì‹œìž‘: SET search_path TO ${schema}, public`);
      await tx.$executeRawUnsafe(`SET search_path TO ${schema}, public`);

      // âœ… ì›ìžì„± DB ì‚­ì œ í›„ ìž¬ìƒì„± (ë ˆê±°ì‹œ ë°ì´í„° ê¸°ì¤€ ë™ê¸°í™”)
      // FK ì œì•½ì¡°ê±´ ìˆœì„œ: ìžì‹ â†’ ë¶€ëª¨
      // â˜…â˜…â˜… ê·¼ë³¸ ë¬¸ì œ í•´ê²°: ëŒ€ì†Œë¬¸ìž ë¬´ê´€ ì‚­ì œ (ê¸°ì¡´ ëŒ€ë¬¸ìž/ì†Œë¬¸ìž ë°ì´í„° ëª¨ë‘ ì‚­ì œ) â˜…â˜…â˜…
      const deleteCondition = { 
        where: { 
          fmeaId: { 
            in: [originalFmeaId, normalizedFmeaId].filter(Boolean) as string[]
          } 
        } 
      };
      console.log(`[API] ì›ìžì„± DB ì´ˆê¸°í™”: fmeaId=${db.fmeaId} (ì›ë³¸: ${originalFmeaId}, ì •ê·œí™”: ${normalizedFmeaId})`);
      await tx.optimization.deleteMany(deleteCondition);
      await tx.riskAnalysis.deleteMany(deleteCondition);
      await tx.failureLink.deleteMany(deleteCondition);
      await tx.failureAnalysis.deleteMany(deleteCondition).catch(() => {});
      await tx.failureCause.deleteMany(deleteCondition);
      await tx.failureMode.deleteMany(deleteCondition);
      await tx.failureEffect.deleteMany(deleteCondition);
      await tx.l3Function.deleteMany(deleteCondition);
      await tx.l2Function.deleteMany(deleteCondition);
      await tx.l1Function.deleteMany(deleteCondition);
      await tx.l3Structure.deleteMany(deleteCondition);
      await tx.l2Structure.deleteMany(deleteCondition);
      await tx.l1Structure.deleteMany(deleteCondition);
      console.log(`[API] ì›ìžì„± DB ì´ˆê¸°í™” ì™„ë£Œ`);

      // 1. L1Structure ì €ìž¥
      if (db.l1Structure) {
        console.log(`[API] L1Structure ì €ìž¥: ${db.l1Structure.name}`);
        await tx.l1Structure.create({
          data: {
            id: db.l1Structure.id,
            fmeaId: db.fmeaId,
            name: db.l1Structure.name,
            confirmed: db.l1Structure.confirmed ?? false,
          },
        });
      }

      // 2. L2Structures ë°°ì¹˜ ì €ìž¥
      if (db.l2Structures.length > 0) {
        console.log(`[API] L2Structures ì €ìž¥: ${db.l2Structures.length}ê°œ`);
        await tx.l2Structure.createMany({
          data: db.l2Structures.map(l2 => ({
            id: l2.id,
            fmeaId: db.fmeaId,
            l1Id: l2.l1Id,
            no: l2.no,
            name: l2.name,
            order: l2.order,
          })),
        });
      }

      // 3. L3Structures ë°°ì¹˜ ì €ìž¥
      if (db.l3Structures.length > 0) {
        await tx.l3Structure.createMany({
          data: db.l3Structures.map(l3 => ({
            id: l3.id,
            fmeaId: db.fmeaId,
            l1Id: l3.l1Id,
            l2Id: l3.l2Id,
            m4: l3.m4 || null,
            name: l3.name,
            order: l3.order,
          })),
        });
      }

      // 4. L1Functions ë°°ì¹˜ ì €ìž¥
      if (db.l1Functions.length > 0) {
        await tx.l1Function.createMany({
          data: db.l1Functions.map(f => ({
            id: f.id,
            fmeaId: db.fmeaId,
            l1StructId: f.l1StructId,
            category: f.category,
            functionName: f.functionName,
            requirement: f.requirement,
          })),
        });
      }

      // 5. L2Functions ë°°ì¹˜ ì €ìž¥
      if (db.l2Functions.length > 0) {
        await tx.l2Function.createMany({
          data: db.l2Functions.map(f => ({
            id: f.id,
            fmeaId: db.fmeaId,
            l2StructId: f.l2StructId,
            functionName: f.functionName,
            productChar: f.productChar,
            specialChar: f.specialChar || null,
          })),
        });
      }

      // 6. L3Functions ë°°ì¹˜ ì €ìž¥
      if (db.l3Functions.length > 0) {
        await tx.l3Function.createMany({
          data: db.l3Functions.map(f => ({
            id: f.id,
            fmeaId: db.fmeaId,
            l3StructId: f.l3StructId,
            l2StructId: f.l2StructId,
            functionName: f.functionName,
            processChar: f.processChar,
            specialChar: f.specialChar || null,
          })),
        });
      }

      // 7. FailureEffects ë°°ì¹˜ ì €ìž¥ - â˜…â˜…â˜… FK ê²€ì¦ í›„ ì €ìž¥ â˜…â˜…â˜…
      let validFeIdSet = new Set(db.failureEffects.map(fe => fe.id));
      if (db.failureEffects.length > 0) {
        const l1FuncIdSet = new Set(db.l1Functions.map(f => f.id));
        
        const validFEs = db.failureEffects.filter(fe => 
          !!fe.l1FuncId && l1FuncIdSet.has(fe.l1FuncId)
        );
        validFeIdSet = new Set(validFEs.map(fe => fe.id));
        
        if (validFEs.length !== db.failureEffects.length) {
          console.warn('[API] âš ï¸ FailureEffects FK ë¶ˆì¼ì¹˜ ì œì™¸:', {
            total: db.failureEffects.length,
            valid: validFEs.length,
            dropped: db.failureEffects.length - validFEs.length,
          });
        }
        
        if (validFEs.length > 0) {
          await tx.failureEffect.createMany({
            data: validFEs.map(fe => ({
              id: fe.id,
              fmeaId: db.fmeaId,
              l1FuncId: fe.l1FuncId,
              category: fe.category,
              effect: fe.effect,
              severity: fe.severity,
              // â˜…â˜…â˜… í•˜ì´ë¸Œë¦¬ë“œ ID ì‹œìŠ¤í…œ í•„ë“œ â˜…â˜…â˜…
              parentId: fe.parentId || null,
              mergeGroupId: fe.mergeGroupId || null,
              rowSpan: fe.rowSpan || 1,
              colSpan: fe.colSpan || 1,
            })),
            skipDuplicates: true,
          });
          console.log(`[API] âœ… FailureEffects ì €ìž¥: ${validFEs.length}ê°œ`);
        }
      }

      // 8. FailureModes ë°°ì¹˜ ì €ìž¥ - â˜…â˜…â˜… FK ê²€ì¦ í›„ ì €ìž¥ â˜…â˜…â˜…
      let validFmIdSet = new Set(db.failureModes.map(fm => fm.id));
      if (db.failureModes.length > 0) {
        const l2FuncIdSet = new Set(db.l2Functions.map(f => f.id));
        const l2StructIdSet = new Set(db.l2Structures.map(s => s.id));
        
        const validFMs = db.failureModes.filter(fm => 
          !!fm.l2FuncId && !!fm.l2StructId &&
          l2FuncIdSet.has(fm.l2FuncId) &&
          l2StructIdSet.has(fm.l2StructId)
        );
        validFmIdSet = new Set(validFMs.map(fm => fm.id));
        
        if (validFMs.length !== db.failureModes.length) {
          console.warn('[API] âš ï¸ FailureModes FK ë¶ˆì¼ì¹˜ ì œì™¸:', {
            total: db.failureModes.length,
            valid: validFMs.length,
            dropped: db.failureModes.length - validFMs.length,
          });
        }
        
        if (validFMs.length > 0) {
          await tx.failureMode.createMany({
            data: validFMs.map(fm => ({
              id: fm.id,
              fmeaId: db.fmeaId,
              l2FuncId: fm.l2FuncId,
              l2StructId: fm.l2StructId,
              productCharId: fm.productCharId || null,
              mode: fm.mode,
              specialChar: fm.specialChar ?? false,
              // â˜…â˜…â˜… í•˜ì´ë¸Œë¦¬ë“œ ID ì‹œìŠ¤í…œ í•„ë“œ â˜…â˜…â˜…
              parentId: fm.parentId || null,
              mergeGroupId: fm.mergeGroupId || null,
              rowSpan: fm.rowSpan || 1,
              colSpan: fm.colSpan || 1,
            })),
            skipDuplicates: true,
          });
          console.log(`[API] âœ… FailureModes ì €ìž¥: ${validFMs.length}ê°œ`);
        }
      }

      // 9. FailureCauses ë°°ì¹˜ ì €ìž¥ - â˜…â˜…â˜… FK ê²€ì¦ í›„ ì €ìž¥ â˜…â˜…â˜…
      let validFcIdSet = new Set(db.failureCauses.map(fc => fc.id));
      if (db.failureCauses.length > 0) {
        const l3FuncIdSet = new Set(db.l3Functions.map(f => f.id));
        const l3StructIdSet = new Set(db.l3Structures.map(s => s.id));
        
        const validFCs = db.failureCauses.filter(fc => 
          !!fc.l3FuncId && !!fc.l3StructId &&
          l3FuncIdSet.has(fc.l3FuncId) &&
          l3StructIdSet.has(fc.l3StructId)
        );
        validFcIdSet = new Set(validFCs.map(fc => fc.id));
        
        if (validFCs.length !== db.failureCauses.length) {
          console.warn('[API] âš ï¸ FailureCauses FK ë¶ˆì¼ì¹˜ ì œì™¸:', {
            total: db.failureCauses.length,
            valid: validFCs.length,
            dropped: db.failureCauses.length - validFCs.length,
          });
        }
        
        if (validFCs.length > 0) {
          await tx.failureCause.createMany({
            data: validFCs.map(fc => ({
              id: fc.id,
              fmeaId: db.fmeaId,
              l3FuncId: fc.l3FuncId,
              l3StructId: fc.l3StructId,
              l2StructId: fc.l2StructId,
              processCharId: fc.processCharId || null,
              cause: fc.cause,
              occurrence: fc.occurrence || null,
              // â˜…â˜…â˜… í•˜ì´ë¸Œë¦¬ë“œ ID ì‹œìŠ¤í…œ í•„ë“œ â˜…â˜…â˜…
              parentId: fc.parentId || null,
              mergeGroupId: fc.mergeGroupId || null,
              rowSpan: fc.rowSpan || 1,
              colSpan: fc.colSpan || 1,
            })),
            skipDuplicates: true,
          });
          console.log(`[API] âœ… FailureCauses ì €ìž¥: ${validFCs.length}ê°œ`);
        }
      }

      // 10. FailureLinks ì €ìž¥ (ê¸°ì¡´ ë§í¬ ì‚­ì œ í›„ ìž¬ìƒì„±)
      if (db.failureLinks.length > 0) {
        // âœ… ê°•ë ¥í•œ ì›ìžì„± ë³´ìž¥:
        // - failure_linksëŠ” fmId/feId/fcId ëª¨ë‘ ìœ íš¨ FKì—¬ì•¼ë§Œ ì €ìž¥ ê°€ëŠ¥
        // - UI íŽ¸ì§‘ ì¤‘(ë¶€ë¶„ ì—°ê²°) ë˜ëŠ” id ë¶ˆì¼ì¹˜ê°€ ì„žì´ë©´ FK(P2003)ë¡œ ì „ì²´ íŠ¸ëžœìž­ì…˜ ë¡¤ë°± â†’ ìƒˆë¡œê³ ì¹¨ ì‹œ "ì‚¬ë¼ì§" ë°œìƒ
        // - í•´ê²°: atomic í…Œì´ë¸”ì— ì‹¤ì œë¡œ ìƒì„±ëœ id ì§‘í•©ìœ¼ë¡œ í•„í„°ë§í•˜ì—¬ "ì™„ì „í•œ ë§í¬ë§Œ" ì €ìž¥
        const fmIdSet = validFmIdSet;
        const feIdSet = validFeIdSet;
        const fcIdSet = validFcIdSet;

        const validLinks = db.failureLinks.filter(link =>
          !!link.fmId && !!link.feId && !!link.fcId &&
          fmIdSet.has(link.fmId) &&
          feIdSet.has(link.feId) &&
          fcIdSet.has(link.fcId)
        );

        const dropped = db.failureLinks.length - validLinks.length;
        if (dropped > 0) {
          console.warn('[API] âš ï¸ failureLinks ì¤‘ FK ë¶ˆì¼ì¹˜/ë¶€ë¶„ ì—°ê²° ì œì™¸:', {
            fmeaId: db.fmeaId,
            total: db.failureLinks.length,
            valid: validLinks.length,
            dropped,
            sampleDropped: db.failureLinks
              .filter(l => !validLinks.includes(l))
              .slice(0, 3)
              .map(l => ({ fmId: l.fmId, feId: l.feId, fcId: l.fcId })),
          });
        }

        await tx.failureLink.createMany({
          data: validLinks.map(link => ({
            id: link.id,
            fmeaId: db.fmeaId,
            fmId: link.fmId,
            feId: link.feId,
            fcId: link.fcId,
            // â˜…â˜…â˜… í•˜ì´ë¸Œë¦¬ë“œ ID ì‹œìŠ¤í…œ í•„ë“œ â˜…â˜…â˜…
            fmSeq: link.fmSeq || null,
            feSeq: link.feSeq || null,
            fcSeq: link.fcSeq || null,
            fmPath: link.fmPath || null,
            fePath: link.fePath || null,
            fcPath: link.fcPath || null,
            parentId: link.parentId || null,
            mergeGroupId: link.mergeGroupId || null,
            rowSpan: link.rowSpan || 1,
            colSpan: link.colSpan || 1,
          })),
          skipDuplicates: true,
        });
      }

      // 11. FailureAnalyses ì €ìž¥ (ê³ ìž¥ë¶„ì„ í†µí•© ë°ì´í„° - All í™”ë©´ ë Œë”ë§ìš©)
      // ê³ ìž¥ì—°ê²° í™•ì • ì‹œ ìžë™ ìƒì„±ëœ ê³ ìž¥ë¶„ì„ í†µí•© ë°ì´í„° ì €ìž¥
      if (db.failureAnalyses && db.failureAnalyses.length > 0) {
        // ê¸°ì¡´ ê³ ìž¥ë¶„ì„ ë°ì´í„° ì‚­ì œ (ê³ ìž¥ì—°ê²° ìž¬í™•ì • ì‹œ ìž¬ìƒì„±)
        await tx.failureAnalysis.deleteMany({ where: { fmeaId: db.fmeaId } });
        
        await tx.failureAnalysis.createMany({
          data: db.failureAnalyses.map(fa => ({
            id: fa.id,
            fmeaId: db.fmeaId,
            linkId: fa.linkId,
            
            // ê³ ìž¥ì—°ê²° ì •ë³´
            fmId: fa.fmId,
            fmText: fa.fmText,
            fmProcessName: fa.fmProcessName,
            
            feId: fa.feId,
            feText: fa.feText,
            feCategory: fa.feCategory,
            feSeverity: fa.feSeverity,
            
            fcId: fa.fcId,
            fcText: fa.fcText,
            fcOccurrence: fa.fcOccurrence || null,
            fcWorkElementName: fa.fcWorkElementName,
            fcM4: fa.fcM4 || null,
            
            // ì—­ì „ê°œ ê¸°ëŠ¥ë¶„ì„ ì •ë³´
            l1FuncId: fa.l1FuncId,
            l1Category: fa.l1Category,
            l1FuncName: fa.l1FuncName,
            l1Requirement: fa.l1Requirement,
            
            l2FuncId: fa.l2FuncId,
            l2FuncName: fa.l2FuncName,
            l2ProductChar: fa.l2ProductChar,
            l2SpecialChar: fa.l2SpecialChar || null,
            
            l3FuncId: fa.l3FuncId,
            l3FuncName: fa.l3FuncName,
            l3ProcessChar: fa.l3ProcessChar,
            l3SpecialChar: fa.l3SpecialChar || null,
            
            // ì—­ì „ê°œ êµ¬ì¡°ë¶„ì„ ì •ë³´
            l1StructId: fa.l1StructId,
            l1StructName: fa.l1StructName,
            
            l2StructId: fa.l2StructId,
            l2StructNo: fa.l2StructNo,
            l2StructName: fa.l2StructName,
            
            l3StructId: fa.l3StructId,
            l3StructM4: fa.l3StructM4 || null,
            l3StructName: fa.l3StructName,
            
            // ë©”íƒ€ë°ì´í„°
            order: fa.order || 0,
            confirmed: fa.confirmed || false,
          })),
          skipDuplicates: true,
        });
        
        console.log(`[API] âœ… FailureAnalyses ì €ìž¥ ì™„ë£Œ: ${db.failureAnalyses.length}ê°œ`);
      } else {
        // ê³ ìž¥ì—°ê²°ì´ í™•ì •ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì—†ìœ¼ë©´ ê¸°ì¡´ ë°ì´í„° ì‚­ì œ
        await tx.failureAnalysis.deleteMany({ where: { fmeaId: db.fmeaId } });
      }

      // 12. RiskAnalyses ë°°ì¹˜ ì €ìž¥
      console.log('[API] RiskAnalyses ì €ìž¥ ì‹œìž‘:', db.riskAnalyses?.length || 0, 'ê°œ');
      if (db.riskAnalyses?.length > 0) {
        console.log('[API] RiskAnalyses ìƒ˜í”Œ:', db.riskAnalyses.slice(0, 3).map(r => ({
          id: r.id?.substring(0, 8),
          linkId: r.linkId?.substring(0, 8),
          S: r.severity,
          O: r.occurrence,
          D: r.detection,
          AP: r.ap,
        })));
        await Promise.all(
          db.riskAnalyses.map(risk =>
            tx.riskAnalysis.upsert({
              where: { id: risk.id },
              create: {
                id: risk.id,
                fmeaId: db.fmeaId,
                linkId: risk.linkId,
                severity: risk.severity,
                occurrence: risk.occurrence,
                detection: risk.detection,
                ap: risk.ap,
                preventionControl: risk.preventionControl || null,
                detectionControl: risk.detectionControl || null,
              },
              update: {
                linkId: risk.linkId,
                severity: risk.severity,
                occurrence: risk.occurrence,
                detection: risk.detection,
                ap: risk.ap,
                preventionControl: risk.preventionControl || null,
                detectionControl: risk.detectionControl || null,
              },
            })
          )
        );
      }

      // 13. Optimizations ë°°ì¹˜ ì €ìž¥
      if (db.optimizations.length > 0) {
        await Promise.all(
          db.optimizations.map(opt =>
            tx.optimization.upsert({
              where: { id: opt.id },
              create: {
                id: opt.id,
                fmeaId: db.fmeaId,
                riskId: opt.riskId,
                recommendedAction: opt.recommendedAction,
                responsible: opt.responsible,
                targetDate: opt.targetDate,
                newSeverity: opt.newSeverity || null,
                newOccurrence: opt.newOccurrence || null,
                newDetection: opt.newDetection || null,
                newAP: opt.newAP || null,
                status: opt.status,
                completedDate: opt.completedDate || null,
              },
              update: {
                riskId: opt.riskId,
                recommendedAction: opt.recommendedAction,
                responsible: opt.responsible,
                targetDate: opt.targetDate,
                newSeverity: opt.newSeverity || null,
                newOccurrence: opt.newOccurrence || null,
                newDetection: opt.newDetection || null,
                newAP: opt.newAP || null,
                status: opt.status,
                completedDate: opt.completedDate || null,
              },
            })
          )
        );
      }

      // âœ… PFMEA Master ìžë™ ì—…ë°ì´íŠ¸ (í”„ë¡œì íŠ¸ ì‹ ê·œ ë°ì´í„° ì¶”ì¶œ â†’ ë§ˆìŠ¤í„° ëˆ„ì )
      // ë§ˆìŠ¤í„° DBëŠ” ê³µìš©(public)ìœ¼ë¡œ ìœ ì§€ (í”„ë¡œì íŠ¸ë³„ DBì™€ ë¶„ë¦¬)
      const publicPrisma = getPrisma();
      if (publicPrisma) {
        await publicPrisma.$transaction(async (pubTx: any) => {
          await upsertActiveMasterFromWorksheetTx(pubTx, db);
        });
      }

      // 13. FmeaConfirmedState ì €ìž¥ (í™•ì • ìƒíƒœ)
      if (db.confirmed) {
        try {
          await tx.fmeaConfirmedState.upsert({
            where: { fmeaId: db.fmeaId },
            create: {
              fmeaId: db.fmeaId,
              structureConfirmed: db.confirmed.structure || false,
              l1FunctionConfirmed: db.confirmed.l1Function || false,
              l2FunctionConfirmed: db.confirmed.l2Function || false,
              l3FunctionConfirmed: db.confirmed.l3Function || false,
              failureL1Confirmed: db.confirmed.l1Failure || false,
              failureL2Confirmed: db.confirmed.l2Failure || false,
              failureL3Confirmed: db.confirmed.l3Failure || false,
              failureLinkConfirmed: db.confirmed.failureLink || false,
              riskConfirmed: db.confirmed.risk || false,
              optimizationConfirmed: db.confirmed.optimization || false,
            },
            update: {
              structureConfirmed: db.confirmed.structure || false,
              l1FunctionConfirmed: db.confirmed.l1Function || false,
              l2FunctionConfirmed: db.confirmed.l2Function || false,
              l3FunctionConfirmed: db.confirmed.l3Function || false,
              failureL1Confirmed: db.confirmed.l1Failure || false,
              failureL2Confirmed: db.confirmed.l2Failure || false,
              failureL3Confirmed: db.confirmed.l3Failure || false,
              failureLinkConfirmed: db.confirmed.failureLink || false,
              riskConfirmed: db.confirmed.risk || false,
              optimizationConfirmed: db.confirmed.optimization || false,
            },
          });
          console.log('[API] âœ… fmeaConfirmedState ì €ìž¥:', db.confirmed);
        } catch (e: any) {
          // í…Œì´ë¸”ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ (ë§ˆì´ê·¸ë ˆì´ì…˜ ì „)
          if (e?.code !== 'P2021') {
            console.warn('[API] í™•ì • ìƒíƒœ ì €ìž¥ ì˜¤ë¥˜ (ë¬´ì‹œ):', e.message);
          }
        }
        
      }
      
      // âœ… FmeaInfo í…Œì´ë¸”ì˜ structureConfirmed ì—…ë°ì´íŠ¸ (ì§ì ‘ pg Pool ì‚¬ìš© - Prisma íŠ¸ëžœìž­ì…˜ ì™¸ë¶€)
      // Prisma íŠ¸ëžœìž­ì…˜ì´ public ìŠ¤í‚¤ë§ˆë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ, í”„ë¡œì íŠ¸ ìŠ¤í‚¤ë§ˆ ì—…ë°ì´íŠ¸ëŠ” ë³„ë„ ì—°ê²° í•„ìš”
      if (db.confirmed) {
        try {
          const pool = new Pool({ connectionString: baseUrl });
          await pool.query(`
            UPDATE "${schema}"."FmeaInfo" 
            SET "structureConfirmed" = $1, "updatedAt" = NOW()
            WHERE "fmeaId" = $2
          `, [db.confirmed.structure || false, db.fmeaId]);
          await pool.end();
          console.log('[API] âœ… FmeaInfo.structureConfirmed ì—…ë°ì´íŠ¸ (ì§ì ‘ Pool):', db.confirmed.structure, 'ìŠ¤í‚¤ë§ˆ:', schema);
        } catch (e: any) {
          console.warn('[API] FmeaInfo ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', e.message);
        }
      }
      
      // â˜…â˜…â˜… 14. FmeaLegacyData ì €ìž¥ (Single Source of Truth) â˜…â˜…â˜…
      // ë ˆê±°ì‹œ ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ì§ì ‘ ì €ìž¥í•˜ì—¬ ì›ìžì„± DB â†” ë ˆê±°ì‹œ ë³€í™˜ ë¬¸ì œ ë°©ì§€
      // âœ… ê¸°ì¡´ ë“±ë¡ì •ë³´(fmeaInfo, project, cftMembers)ëŠ” ìœ ì§€í•˜ê³  ì›Œí¬ì‹œíŠ¸ ë°ì´í„°ë§Œ ì—…ë°ì´íŠ¸
      if (legacyData) {
        try {
          // ê¸°ì¡´ ë°ì´í„° ì¡°íšŒ (ë“±ë¡ì •ë³´ ë³´ì¡´ìš©)
          const existingLegacy = await tx.fmeaLegacyData.findUnique({
            where: { fmeaId: db.fmeaId }
          }).catch(() => null);
          
          // ê¸°ì¡´ ë“±ë¡ì •ë³´ ë³´ì¡´ (ìžˆìœ¼ë©´ ìœ ì§€, ì—†ìœ¼ë©´ ìƒˆ ë°ì´í„° ì‚¬ìš©)
          const existingData = existingLegacy?.data as any || {};
          
          // âœ… "(ìžë™ìƒì„±)" í”Œë ˆì´ìŠ¤í™€ë” ë°ì´í„° ì™„ì „ ì œê±°
          const cleanedLegacyData = cleanAutoGeneratedData(legacyData);
          
          const mergedLegacyData = {
            ...cleanedLegacyData,  // ì›Œí¬ì‹œíŠ¸ ë°ì´í„° (l1, l2, failureLinks ë“±) - ì •ë¦¬ëœ ë²„ì „
            // âœ… ê¸°ì¡´ ë“±ë¡ì •ë³´ ë³´ì¡´ (ì›Œí¬ì‹œíŠ¸ ì €ìž¥ ì‹œ ë®ì–´ì“°ì§€ ì•ŠìŒ)
            fmeaInfo: cleanedLegacyData.fmeaInfo || existingData.fmeaInfo,
            project: cleanedLegacyData.project || existingData.project,
            cftMembers: cleanedLegacyData.cftMembers || existingData.cftMembers,
            fmeaType: cleanedLegacyData.fmeaType || existingData.fmeaType,
            parentFmeaId: cleanedLegacyData.parentFmeaId || existingData.parentFmeaId,
            parentFmeaType: cleanedLegacyData.parentFmeaType || existingData.parentFmeaType,
          };
          
          await tx.fmeaLegacyData.upsert({
            where: { fmeaId: db.fmeaId },
            create: {
              fmeaId: db.fmeaId,
              data: mergedLegacyData,
              version: LEGACY_DATA_VERSION,
            },
            update: {
              data: mergedLegacyData,
              version: LEGACY_DATA_VERSION,
            },
          });
          console.log('[API] âœ… ë ˆê±°ì‹œ ë°ì´í„° DB ì €ìž¥ ì™„ë£Œ (ë“±ë¡ì •ë³´ ë³´ì¡´ë¨)', {
            riskDataCount: Object.keys(mergedLegacyData.riskData || {}).length,
            riskDataKeys: Object.keys(mergedLegacyData.riskData || {}).slice(0, 5),
          });
        } catch (e: any) {
          // í…Œì´ë¸”ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ (ë§ˆì´ê·¸ë ˆì´ì…˜ ì „)
          if (e?.code !== 'P2021') {
            console.warn('[API] ë ˆê±°ì‹œ ë°ì´í„° ì €ìž¥ ì˜¤ë¥˜ (ë¬´ì‹œ):', e.message);
          }
        }
      }
      
      // â˜…â˜…â˜… 15. FmeaWorksheetData ì €ìž¥ (ì›Œí¬ì‹œíŠ¸ ë°ì´í„° ë°±ì—…) â˜…â˜…â˜…
      // FmeaLegacyDataì™€ í•¨ê»˜ ì›Œí¬ì‹œíŠ¸ ë°ì´í„°ë¥¼ ë³„ë„ë¡œ ì €ìž¥
      if (legacyData) {
        try {
          // âœ… "(ìžë™ìƒì„±)" í”Œë ˆì´ìŠ¤í™€ë” ì œê±°ëœ ë°ì´í„° ì‚¬ìš©
          const cleanedForWorksheet = cleanAutoGeneratedData(legacyData);
          await tx.fmeaWorksheetData.upsert({
            where: { fmeaId: db.fmeaId },
            create: {
              fmeaId: db.fmeaId,
              l1Data: cleanedForWorksheet.l1 || null,
              l2Data: cleanedForWorksheet.l2 || null,
              riskData: cleanedForWorksheet.riskData || null,
              failureLinks: cleanedForWorksheet.failureLinks || null,
              tab: cleanedForWorksheet.tab || 'structure',
              version: LEGACY_DATA_VERSION,
            },
            update: {
              l1Data: cleanedForWorksheet.l1 || null,
              l2Data: cleanedForWorksheet.l2 || null,
              riskData: cleanedForWorksheet.riskData || null,
              failureLinks: cleanedForWorksheet.failureLinks || null,
              tab: cleanedForWorksheet.tab || 'structure',
              version: LEGACY_DATA_VERSION,
            },
          });
          console.log('[API] âœ… FmeaWorksheetData ì €ìž¥ ì™„ë£Œ', {
            l1Name: (cleanedForWorksheet.l1 as any)?.name,
            l2Count: (cleanedForWorksheet.l2 as any[])?.length || 0,
            failureLinksCount: (cleanedForWorksheet.failureLinks as any[])?.length || 0,
          });
        } catch (e: any) {
          // í…Œì´ë¸”ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ (ë§ˆì´ê·¸ë ˆì´ì…˜ ì „)
          if (e?.code !== 'P2021') {
            console.warn('[API] FmeaWorksheetData ì €ìž¥ ì˜¤ë¥˜ (ë¬´ì‹œ):', e.message);
          }
        }
      }
    }, {
      timeout: TRANSACTION_TIMEOUT,
    });

    return NextResponse.json({
      success: true,
      message: 'FMEA data saved successfully',
      fmeaId: db.fmeaId,
      savedAt: new Date().toISOString(),
    });
  } catch (error: any) {
    console.error('[API] FMEA ì €ìž¥ ì˜¤ë¥˜:', error);
    
    // ì—°ê²° ì—ëŸ¬ì¸ ê²½ìš° localStorage í´ë°± ê°€ëŠ¥í•˜ë„ë¡ 200 ë°˜í™˜
    const isConnectionError = 
      error.code === 'P1001' || // Connection timeout
      error.code === 'P1002' || // Database server connection timeout
      error.code === 'P1003' || // Database does not exist
      error.code === 'P1017' || // Server has closed the connection
      error.message?.includes('connect') ||
      error.message?.includes('timeout') ||
      error.message?.includes('ECONNREFUSED');
    
    if (isConnectionError) {
      console.warn('[API] DB ì—°ê²° ì—ëŸ¬ - localStorage í´ë°± ê°€ëŠ¥:', error.message);
      return NextResponse.json(
        { 
          success: false,
          error: 'Database connection error',
          message: 'ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. localStorageë¡œ í´ë°±ë©ë‹ˆë‹¤.',
          code: error.code,
          details: error.message,
          fallback: true
        },
        { status: 200 } // 200ìœ¼ë¡œ ë°˜í™˜í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ê°€ localStorageë¡œ í´ë°±í•  ìˆ˜ ìžˆë„ë¡
      );
    }
    
    // Prisma ì—ëŸ¬ ìƒì„¸ ì •ë³´
    if (error.code) {
      return NextResponse.json(
        { 
          success: false,
          error: 'Failed to save FMEA data',
          code: error.code,
          details: error.meta || error.message,
        },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      { 
        success: false,
        error: 'Failed to save FMEA data', 
        details: error.message 
      },
      { status: 500 }
    );
  }
}

/**
 * FMEA ë°ì´í„° ë¡œë“œ
 * 
 * â˜…â˜…â˜… ê·¼ë³¸ì ì¸ í•´ê²°ì±…: ë ˆê±°ì‹œ ë°ì´í„° ìš°ì„  ë¡œë“œ â˜…â˜…â˜…
 * 1. FmeaLegacyData í…Œì´ë¸”ì—ì„œ ë ˆê±°ì‹œ ë°ì´í„° ë¡œë“œ (Single Source of Truth)
 * 2. ë ˆê±°ì‹œ ë°ì´í„°ê°€ ìžˆìœ¼ë©´ ê·¸ê²ƒì„ ì§ì ‘ ì‚¬ìš© (ì—­ë³€í™˜ ê³¼ì • ì—†ìŒ!)
 * 3. ë ˆê±°ì‹œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì›ìžì„± DBì—ì„œ ì—­ë³€í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)
 */
export async function GET(request: NextRequest) {
  try {
    const baseUrl = getBaseDatabaseUrl();
    if (!baseUrl) {
      console.warn('[API] Prisma ë¯¸í™œì„±(null), null ë°˜í™˜ (localStorage í´ë°± ì‚¬ìš©)');
      return NextResponse.json(null);
    }

    const searchParams = request.nextUrl.searchParams;
    // â˜… FMEA IDëŠ” ì†Œë¬¸ìžë¡œ ì •ê·œí™” (DB ì¼ê´€ì„± ë³´ìž¥)
    const originalQueryFmeaId = searchParams.get('fmeaId');
    const fmeaId = originalQueryFmeaId?.toLowerCase();
    // â˜… ëŒ€ì†Œë¬¸ìž ë¬´ê´€ ê²€ìƒ‰ìš© ë°°ì—´
    const fmeaIdVariants = [originalQueryFmeaId, fmeaId].filter(Boolean) as string[];
    const format = searchParams.get('format'); // 'atomic' | undefined

    if (!fmeaId) {
      return NextResponse.json(
        { error: 'fmeaId parameter is required' },
        { status: 400 }
      );
    }

    // âœ… format=atomicì´ë©´ legacy ìš°ì„  ë¡œë“œë¥¼ ìŠ¤í‚µí•˜ê³  ì›ìžì„± DBë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜
    // (ë³µêµ¬/ê²€ì¦/íƒ€ ëª¨ë“ˆ ì—°ë™ì„ ìœ„í•´ raw atomicì´ í•„ìš”í•  ë•Œ ì‚¬ìš©)
    const forceAtomic = format === 'atomic';

    // âœ… í”„ë¡œì íŠ¸ë³„ DB(ìŠ¤í‚¤ë§ˆ) ê·œì¹™ ì ìš©
    const schema = getProjectSchemaName(fmeaId);
    await ensureProjectSchemaReady({ baseDatabaseUrl: baseUrl, schema });
    const prisma = getPrismaForSchema(schema);
    if (!prisma) {
      console.warn('[API] Prisma ë¯¸í™œì„±(null), null ë°˜í™˜ (localStorage í´ë°± ì‚¬ìš©)');
      return NextResponse.json(null);
    }
    
    // âœ… ê°•ë ¥í•œ ìŠ¤í‚¤ë§ˆ ê°•ì œ: ì¡°íšŒ ì „ search_path ì„¤ì •
    await prisma.$executeRawUnsafe(`SET search_path TO ${schema}, public`);
    
    // â˜…â˜…â˜… 1ë‹¨ê³„: ë ˆê±°ì‹œ ë°ì´í„° ìš°ì„  ë¡œë“œ (Single Source of Truth) â˜…â˜…â˜…
    // â˜… ëŒ€ì†Œë¬¸ìž ë¬´ê´€ ê²€ìƒ‰: ê¸°ì¡´ ëŒ€ë¬¸ìž/ì†Œë¬¸ìž ë°ì´í„° ëª¨ë‘ ì§€ì›
    let legacyDataRecord: any = null;
    try {
      legacyDataRecord = await prisma.fmeaLegacyData.findFirst({
        where: { fmeaId: { in: fmeaIdVariants } }
      });
    } catch (e: any) {
      // í…Œì´ë¸”ì´ ì—†ìœ¼ë©´ ìŠ¤í‚µ (ë§ˆì´ê·¸ë ˆì´ì…˜ ì „)
      if (e?.code !== 'P2021') {
        console.warn('[API] ë ˆê±°ì‹œ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜ (ë¬´ì‹œ):', e.message);
      }
    }

    // âœ… í”„ë¡œì íŠ¸ ìŠ¤í‚¤ë§ˆì— ë ˆê±°ì‹œê°€ ì—†ìœ¼ë©´ public(ê¸°ì¡´ ì €ìž¥ì†Œ)ì—ì„œ 1íšŒ ë§ˆì´ê·¸ë ˆì´ì…˜
    // â˜… ëŒ€ì†Œë¬¸ìž ë¬´ê´€ ê²€ìƒ‰: ê¸°ì¡´ ëŒ€ë¬¸ìž/ì†Œë¬¸ìž ë°ì´í„° ëª¨ë‘ ì§€ì›
    if (!legacyDataRecord?.data) {
      const publicPrisma = getPrisma();
      const fromPublic = await publicPrisma?.fmeaLegacyData.findFirst({ 
        where: { fmeaId: { in: fmeaIdVariants } } 
      }).catch(() => null);
      if (fromPublic?.data) {
        await prisma.fmeaLegacyData.upsert({
          where: { fmeaId },
          create: { fmeaId, data: fromPublic.data, version: fromPublic.version || '1.0.0' },
          update: { data: fromPublic.data, version: fromPublic.version || '1.0.0' },
        });
        legacyDataRecord = await prisma.fmeaLegacyData.findFirst({ 
          where: { fmeaId: { in: fmeaIdVariants } } 
        }).catch(() => null);
      }
    }
    
    // â˜…â˜…â˜… ë ˆê±°ì‹œ ë°ì´í„°ê°€ ìžˆìœ¼ë©´ ì§ì ‘ ë°˜í™˜ (ì—­ë³€í™˜ ê³¼ì • ì—†ìŒ!) â˜…â˜…â˜…
    if (!forceAtomic && legacyDataRecord && legacyDataRecord.data) {
      console.log('[API] âœ… ë ˆê±°ì‹œ ë°ì´í„° DBì—ì„œ ì§ì ‘ ë¡œë“œ (Single Source of Truth)');
      
      // âœ… "(ìžë™ìƒì„±)" í”Œë ˆì´ìŠ¤í™€ë” ë°ì´í„° ì œê±° í›„ ë°˜í™˜
      const cleanedLegacyData = cleanAutoGeneratedData(legacyDataRecord.data);
      
      // í™•ì • ìƒíƒœë„ í•¨ê»˜ ë¡œë“œ
      const confirmedState = await prisma.fmeaConfirmedState.findUnique({
        where: { fmeaId }
      }).catch(() => null);
      
      // ë ˆê±°ì‹œ ë°ì´í„°ì— confirmed ìƒíƒœ ì¶”ê°€
      const legacyWithConfirmed = {
        ...cleanedLegacyData,
        confirmed: {
          structure: confirmedState?.structureConfirmed ?? false,
          l1Function: confirmedState?.l1FunctionConfirmed ?? false,
          l2Function: confirmedState?.l2FunctionConfirmed ?? false,
          l3Function: confirmedState?.l3FunctionConfirmed ?? false,
          l1Failure: confirmedState?.failureL1Confirmed ?? false,
          l2Failure: confirmedState?.failureL2Confirmed ?? false,
          l3Failure: confirmedState?.failureL3Confirmed ?? false,
          failureLink: confirmedState?.failureLinkConfirmed ?? false,
          risk: confirmedState?.riskConfirmed ?? false,
          optimization: confirmedState?.optimizationConfirmed ?? false,
        },
        // í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ë ˆê±°ì‹œ ë°ì´í„°ìž„ì„ ì•Œ ìˆ˜ ìžˆë„ë¡ í”Œëž˜ê·¸ ì¶”ê°€
        _isLegacyDirect: true,
        _legacyVersion: legacyDataRecord.version,
        _loadedAt: new Date().toISOString(),
      };
      
      return NextResponse.json(legacyWithConfirmed);
    }
    
    if (forceAtomic) {
      console.log('[API] format=atomic ìš”ì²­ - ì›ìžì„± DBë¥¼ ê·¸ëŒ€ë¡œ ë°˜í™˜');
    } else {
      console.log('[API] âš ï¸ ë ˆê±°ì‹œ ë°ì´í„° ì—†ìŒ, ì›ìžì„± DBì—ì„œ ì—­ë³€í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)');
    }

    // ëª¨ë“  ë°ì´í„°ë¥¼ ë³‘ë ¬ë¡œ ì¡°íšŒ (í•˜ìœ„ í˜¸í™˜ì„±)
    // âœ… failureAnalysisëŠ” ë³„ë„ë¡œ ì²˜ë¦¬ (í…Œì´ë¸”ì´ ì—†ì„ ìˆ˜ ìžˆìŒ)
    let failureAnalyses: any[] = [];
    try {
      failureAnalyses = await prisma.failureAnalysis.findMany({ 
        where: { fmeaId }, 
        orderBy: { order: 'asc' } 
      });
    } catch (e: any) {
      // í…Œì´ë¸”ì´ ì—†ê±°ë‚˜ ëª¨ë¸ì´ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)
      if (e?.code === 'P2021' || e?.message?.includes('does not exist')) {
        console.warn('[API] failure_analyses í…Œì´ë¸” ì—†ìŒ, ë¹ˆ ë°°ì—´ ë°˜í™˜ (í•˜ìœ„ í˜¸í™˜ì„±)');
      } else {
        console.warn('[API] failure_analyses ì¡°íšŒ ì˜¤ë¥˜:', e.message);
      }
    }
    
    const [
      l1Structure,
      l2Structures,
      l3Structures,
      l1Functions,
      l2Functions,
      l3Functions,
      failureEffects,
      failureModes,
      failureCauses,
      failureLinks,
      riskAnalyses,
      optimizations,
      confirmedState,
    ] = await Promise.all([
      prisma.l1Structure.findFirst({ where: { fmeaId } }),
      prisma.l2Structure.findMany({ where: { fmeaId }, orderBy: { order: 'asc' } }),
      prisma.l3Structure.findMany({ where: { fmeaId }, orderBy: { order: 'asc' } }),
      prisma.l1Function.findMany({ where: { fmeaId } }),
      prisma.l2Function.findMany({ where: { fmeaId } }),
      prisma.l3Function.findMany({ where: { fmeaId } }),
      prisma.failureEffect.findMany({ where: { fmeaId } }),
      prisma.failureMode.findMany({ where: { fmeaId } }),
      prisma.failureCause.findMany({ where: { fmeaId } }),
      prisma.failureLink.findMany({ where: { fmeaId } }),
      prisma.riskAnalysis.findMany({ where: { fmeaId } }),
      prisma.optimization.findMany({ where: { fmeaId } }),
      // í™•ì • ìƒíƒœ ë¡œë“œ (í…Œì´ë¸” ì—†ìœ¼ë©´ null ë°˜í™˜)
      prisma.fmeaConfirmedState.findUnique({ where: { fmeaId } }).catch(() => null),
    ]);

    // ë°ì´í„°ê°€ ì—†ìœ¼ë©´ null ë°˜í™˜
    if (!l1Structure && l2Structures.length === 0) {
      return NextResponse.json(null);
    }

    // FMEAWorksheetDB í˜•ì‹ìœ¼ë¡œ ë³€í™˜
    const db: FMEAWorksheetDB = {
      fmeaId,
      savedAt: l1Structure?.updatedAt.toISOString() || new Date().toISOString(),
      l1Structure: l1Structure ? {
        id: l1Structure.id,
        fmeaId: l1Structure.fmeaId,
        name: l1Structure.name,
        confirmed: l1Structure.confirmed ?? false,
        createdAt: l1Structure.createdAt.toISOString(),
        updatedAt: l1Structure.updatedAt.toISOString(),
      } : null,
      l2Structures: l2Structures.map((l2: any) => ({
        id: l2.id,
        fmeaId: l2.fmeaId,
        l1Id: l2.l1Id,
        no: l2.no,
        name: l2.name,
        order: l2.order,
        createdAt: l2.createdAt.toISOString(),
        updatedAt: l2.updatedAt.toISOString(),
      })),
      l3Structures: l3Structures.map((l3: any) => ({
        id: l3.id,
        fmeaId: l3.fmeaId,
        l1Id: l3.l1Id,
        l2Id: l3.l2Id,
        m4: (l3.m4 as any) || '',
        name: l3.name,
        order: l3.order,
        createdAt: l3.createdAt.toISOString(),
        updatedAt: l3.updatedAt.toISOString(),
      })),
      l1Functions: l1Functions.map((f: any) => ({
        id: f.id,
        fmeaId: f.fmeaId,
        l1StructId: f.l1StructId,
        category: f.category as any,
        functionName: f.functionName,
        requirement: f.requirement,
        createdAt: f.createdAt.toISOString(),
        updatedAt: f.updatedAt.toISOString(),
      })),
      l2Functions: l2Functions.map((f: any) => ({
        id: f.id,
        fmeaId: f.fmeaId,
        l2StructId: f.l2StructId,
        functionName: f.functionName,
        productChar: f.productChar,
        specialChar: f.specialChar || undefined,
        createdAt: f.createdAt.toISOString(),
        updatedAt: f.updatedAt.toISOString(),
      })),
      l3Functions: l3Functions.map((f: any) => ({
        id: f.id,
        fmeaId: f.fmeaId,
        l3StructId: f.l3StructId,
        l2StructId: f.l2StructId,
        functionName: f.functionName,
        processChar: f.processChar,
        specialChar: f.specialChar || undefined,
        createdAt: f.createdAt.toISOString(),
        updatedAt: f.updatedAt.toISOString(),
      })),
      failureEffects: failureEffects.map((fe: any) => ({
        id: fe.id,
        fmeaId: fe.fmeaId,
        l1FuncId: fe.l1FuncId,
        category: fe.category as any,
        effect: fe.effect,
        severity: fe.severity,
        createdAt: fe.createdAt.toISOString(),
        updatedAt: fe.updatedAt.toISOString(),
      })),
      failureModes: failureModes.map((fm: any) => ({
        id: fm.id,
        fmeaId: fm.fmeaId,
        l2FuncId: fm.l2FuncId,
        l2StructId: fm.l2StructId,
        productCharId: fm.productCharId || undefined,
        mode: fm.mode,
        specialChar: fm.specialChar ?? false,
        createdAt: fm.createdAt.toISOString(),
        updatedAt: fm.updatedAt.toISOString(),
      })),
      failureCauses: failureCauses.map((fc: any) => ({
        id: fc.id,
        fmeaId: fc.fmeaId,
        l3FuncId: fc.l3FuncId,
        l3StructId: fc.l3StructId,
        l2StructId: fc.l2StructId,
        cause: fc.cause,
        occurrence: fc.occurrence || undefined,
        createdAt: fc.createdAt.toISOString(),
        updatedAt: fc.updatedAt.toISOString(),
      })),
      failureLinks: failureLinks.map((link: any) => ({
        id: link.id,
        fmeaId: link.fmeaId,
        fmId: link.fmId,
        feId: link.feId,
        fcId: link.fcId,
        createdAt: link.createdAt.toISOString(),
        updatedAt: link.updatedAt.toISOString(),
      })),
      // ê³ ìž¥ë¶„ì„ í†µí•© ë°ì´í„° (All í™”ë©´ ë Œë”ë§ìš©)
      failureAnalyses: (failureAnalyses || []).map((fa: any) => ({
        id: fa.id,
        fmeaId: fa.fmeaId,
        linkId: fa.linkId,
        // ê³ ìž¥ì—°ê²° ì •ë³´
        fmId: fa.fmId,
        fmText: fa.fmText,
        fmProcessName: fa.fmProcessName,
        feId: fa.feId,
        feText: fa.feText,
        feCategory: fa.feCategory,
        feSeverity: fa.feSeverity,
        fcId: fa.fcId,
        fcText: fa.fcText,
        fcOccurrence: fa.fcOccurrence || undefined,
        fcWorkElementName: fa.fcWorkElementName,
        fcM4: fa.fcM4 || undefined,
        // ì—­ì „ê°œ ê¸°ëŠ¥ë¶„ì„
        l1FuncId: fa.l1FuncId,
        l1Category: fa.l1Category,
        l1FuncName: fa.l1FuncName,
        l1Requirement: fa.l1Requirement,
        l2FuncId: fa.l2FuncId,
        l2FuncName: fa.l2FuncName,
        l2ProductChar: fa.l2ProductChar,
        l2SpecialChar: fa.l2SpecialChar || undefined,
        l3FuncId: fa.l3FuncId,
        l3FuncName: fa.l3FuncName,
        l3ProcessChar: fa.l3ProcessChar,
        l3SpecialChar: fa.l3SpecialChar || undefined,
        // ì—­ì „ê°œ êµ¬ì¡°ë¶„ì„
        l1StructId: fa.l1StructId,
        l1StructName: fa.l1StructName,
        l2StructId: fa.l2StructId,
        l2StructNo: fa.l2StructNo,
        l2StructName: fa.l2StructName,
        l3StructId: fa.l3StructId,
        l3StructM4: fa.l3StructM4 || undefined,
        l3StructName: fa.l3StructName,
        // ë©”íƒ€ë°ì´í„°
        order: fa.order,
        confirmed: fa.confirmed,
        createdAt: fa.createdAt.toISOString(),
        updatedAt: fa.updatedAt.toISOString(),
      })),
      riskAnalyses: riskAnalyses.map((risk: any) => ({
        id: risk.id,
        fmeaId: risk.fmeaId,
        linkId: risk.linkId,
        severity: risk.severity,
        occurrence: risk.occurrence,
        detection: risk.detection,
        ap: risk.ap as any,
        preventionControl: risk.preventionControl || undefined,
        detectionControl: risk.detectionControl || undefined,
        createdAt: risk.createdAt.toISOString(),
        updatedAt: risk.updatedAt.toISOString(),
      })),
      optimizations: optimizations.map((opt: any) => ({
        id: opt.id,
        fmeaId: opt.fmeaId,
        riskId: opt.riskId,
        recommendedAction: opt.recommendedAction,
        responsible: opt.responsible,
        targetDate: opt.targetDate,
        newSeverity: opt.newSeverity || undefined,
        newOccurrence: opt.newOccurrence || undefined,
        newDetection: opt.newDetection || undefined,
        newAP: opt.newAP as any || undefined,
        status: opt.status as any,
        completedDate: opt.completedDate || undefined,
        createdAt: opt.createdAt.toISOString(),
        updatedAt: opt.updatedAt.toISOString(),
      })),
      confirmed: {
        structure: confirmedState?.structureConfirmed ?? l1Structure?.confirmed ?? false,
        l1Function: confirmedState?.l1FunctionConfirmed ?? false,
        l2Function: confirmedState?.l2FunctionConfirmed ?? false,
        l3Function: confirmedState?.l3FunctionConfirmed ?? false,
        l1Failure: confirmedState?.failureL1Confirmed ?? false,
        l2Failure: confirmedState?.failureL2Confirmed ?? false,
        l3Failure: confirmedState?.failureL3Confirmed ?? false,
        failureLink: confirmedState?.failureLinkConfirmed ?? false,
        risk: confirmedState?.riskConfirmed ?? false,
        optimization: confirmedState?.optimizationConfirmed ?? false,
      },
    };

    return NextResponse.json(db);
  } catch (error: any) {
    console.error('[API] FMEA ë¡œë“œ ì˜¤ë¥˜:', error);
    
    // Prisma ì—ëŸ¬ ìƒì„¸ ì •ë³´
    if (error.code) {
      return NextResponse.json(
        { 
          error: 'Failed to load FMEA data',
          code: error.code,
          details: error.meta || error.message,
        },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      { error: 'Failed to load FMEA data', details: error.message },
      { status: 500 }
    );
  }
}
