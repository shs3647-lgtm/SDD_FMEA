/**
 * @file api/sync/structure/route.ts
 * @description 구조 동기화 API
 * @module sync/api
 */

import { NextRequest, NextResponse } from 'next/server';
import { getPrisma, getPrismaForSchema, getBaseDatabaseUrl } from '@/lib/prisma';
import { getProjectSchemaName, ensureProjectSchemaReady } from '@/lib/project-schema';

// ============================================================================
// 4M 정규화 유틸리티
// ============================================================================

/**
 * 4M 값 정규화 함수
 * - 다양한 소스(DB, 레거시, PFD 등)에서 오는 4M 값을 표준 형식으로 변환
 * - 표준 값: 'MN' (Man), 'MC' (Machine), 'IM' (In-Material), 'EN' (Environment)
 */
function normalize4M(value: any): 'MN' | 'MC' | 'IM' | 'EN' | '' {
  if (!value) return '';
  const v = String(value).trim().toUpperCase();
  
  // 이미 표준 형식인 경우
  if (['MN', 'MC', 'IM', 'EN'].includes(v)) {
    return v as 'MN' | 'MC' | 'IM' | 'EN';
  }
  
  // PFD/레거시 형식 변환
  switch (v) {
    case 'MAN':
    case 'WORKER':
    case '작업자':
      return 'MN';
    case 'MACHINE':
    case 'EQUIPMENT':
    case '설비':
    case '기계':
      return 'MC';
    case 'MATERIAL':
    case 'IN-MATERIAL':
    case 'INMATERIAL':
    case '자재':
    case '부자재':
    case 'MT': // 일부 레거시에서 MT 사용
      return 'IM';
    case 'METHOD':
    case 'ENVIRONMENT':
    case 'ENV':
    case '환경':
    case 'ME': // Method/Environment
      return 'EN';
    default:
      return '';
  }
}

/**
 * L3 객체에서 4M 값 추출 (m4, fourM, 4m 등 다양한 필드명 지원)
 */
function get4MFromL3(l3: any): 'MN' | 'MC' | 'IM' | 'EN' | '' {
  // 다양한 필드명에서 값 추출 시도
  const rawValue = l3?.m4 || l3?.fourM || l3?.['4m'] || l3?.category4M || l3?.category || '';
  return normalize4M(rawValue);
}

/**
 * 설비/금형/지그 여부 확인 (MC, IM, EN만 해당)
 */
function isEquipment4M(m4: string): boolean {
  const normalized = normalize4M(m4);
  return ['MC', 'IM', 'EN'].includes(normalized);
}

/**
 * Man(작업자) 여부 확인
 */
function isMan4M(m4: string): boolean {
  return normalize4M(m4) === 'MN';
}

// ============================================================================
// 타입 정의
// ============================================================================

type SyncDirection = 
  | 'fmea-to-cp' | 'cp-to-fmea' 
  | 'pfd-to-fmea' | 'fmea-to-pfd'
  | 'pfd-to-cp' | 'cp-to-pfd';

interface StructureSyncRequest {
  direction: SyncDirection;
  sourceId: string;
  targetId?: string;
  data?: any;
  options?: {
    overwrite?: boolean;
    createEmpty?: boolean;
    preserveTarget?: string[];
  };
}

// ============================================================================
// POST: 구조 동기화
// ============================================================================

// GET: 구조 데이터 조회 (디버깅용)
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const fmeaId = searchParams.get('fmeaId');
    
    if (!fmeaId) {
      return NextResponse.json({ success: false, error: 'fmeaId 필요' });
    }
    
    const prisma = getPrisma();
    
    // L2Structure 조회 (관련 데이터 포함)
    const l2Structures = await prisma.l2Structure.findMany({
      where: { fmeaId },
      include: {
        l3Structures: {
          include: { l3Functions: true },
        },
        l2Functions: true,
      },
      orderBy: { order: 'asc' },
    });
    
    return NextResponse.json({
      success: true,
      fmeaId,
      l2Count: l2Structures.length,
      l2Structures: l2Structures.map(l2 => ({
        id: l2.id,
        no: l2.no,
        name: l2.name,
        l3Count: l2.l3Structures?.length || 0,
        l2FunctionCount: l2.l2Functions?.length || 0,
        l3Structures: l2.l3Structures?.map(l3 => ({
          id: l3.id,
          name: l3.name,
          m4Raw: l3.m4, // 원본 DB 값
          m4Normalized: get4MFromL3(l3), // 정규화된 값
          isEquipment: isEquipment4M(l3.m4 || ''), // 설비 여부
          isMan: isMan4M(l3.m4 || ''), // Man 여부
          l3FunctionCount: l3.l3Functions?.length || 0,
          l3Functions: l3.l3Functions?.map(fn => ({
            processChar: fn.processChar,
            specialChar: fn.specialChar,
          })),
        })),
        l2Functions: l2.l2Functions?.map(fn => ({
          productChar: fn.productChar,
          specialChar: fn.specialChar,
        })),
      })),
    });
  } catch (error: any) {
    return NextResponse.json({ success: false, error: error.message });
  }
}

export async function POST(req: NextRequest) {
  try {
    const body: StructureSyncRequest = await req.json();
    const { direction, sourceId, targetId, data, options } = body;

    // 필수 파라미터 검증
    if (!direction || !sourceId) {
      return NextResponse.json(
        { success: false, error: '필수 파라미터 누락 (direction, sourceId)' },
        { status: 400 }
      );
    }

    const prisma = getPrisma();

    // 방향에 따라 처리
    switch (direction) {
      case 'fmea-to-cp':
        return await syncFmeaToCp(prisma, sourceId, targetId, options);
      case 'cp-to-fmea':
        return await syncCpToFmea(prisma, sourceId, targetId, data, options);
      case 'pfd-to-fmea':
        return await syncPfdToFmea(prisma, sourceId, targetId, options);
      case 'fmea-to-pfd':
        return await syncFmeaToPfd(prisma, sourceId, targetId, options);
      case 'pfd-to-cp':
        return await syncPfdToCp(prisma, sourceId, targetId, options);
      case 'cp-to-pfd':
        return await syncCpToPfd(prisma, sourceId, targetId, options);
      default:
        return NextResponse.json(
          { success: false, error: '잘못된 동기화 방향' },
          { status: 400 }
        );
    }

  } catch (error: any) {
    console.error('[API] 구조 동기화 실패:', error);
    return NextResponse.json(
      { success: false, error: error.message || '서버 오류' },
      { status: 500 }
    );
  }
}

// ============================================================================
// FMEA → CP 구조 동기화
// ============================================================================

async function syncFmeaToCp(
  prisma: any,
  fmeaId: string,
  cpNo?: string,
  options?: any
): Promise<NextResponse> {
  try {
    // ★ 2026-01-16: 프로젝트 스키마에서 FMEA 데이터 조회
    const baseUrl = getBaseDatabaseUrl();
    const fmeaIdLower = fmeaId.toLowerCase();
    const schema = getProjectSchemaName(fmeaIdLower);
    
    let projectPrisma = prisma;
    if (baseUrl) {
      await ensureProjectSchemaReady({ baseDatabaseUrl: baseUrl, schema });
      projectPrisma = getPrismaForSchema(schema) || prisma;
      console.log(`[SYNC] 프로젝트 스키마 사용: ${schema}`);
    }
    
    // 1. FMEA 데이터 조회 (L2Structures + L3Structures + Functions)
    let l2Structures = await projectPrisma.l2Structure.findMany({
      where: {
        fmeaId: fmeaId,
      },
      include: {
        l3Structures: {
          include: {
            l3Functions: true, // 공정특성
          },
          orderBy: { order: 'asc' },
        },
        l2Functions: true, // 제품특성
      },
      orderBy: { order: 'asc' },
    });

    // ★ 2026-01-16: L2Structure가 없으면 fmea_legacy_data 또는 fmea_worksheet_data에서 레거시 데이터 조회
    if (!l2Structures || l2Structures.length === 0) {
      console.log('[SYNC] L2Structure 없음, 레거시 데이터 조회 시도');
      
      try {
        // 1차: fmea_legacy_data 조회
        let legacyL2: any[] = [];
        const legacyData = await projectPrisma.fmeaLegacyData.findUnique({
          where: { fmeaId: fmeaIdLower },
        }).catch(() => null);
        
        if (legacyData?.data) {
          const data = legacyData.data as any;
          legacyL2 = data.l2 || [];
          console.log(`[SYNC] fmea_legacy_data에서 ${legacyL2.length}개 공정 발견`);
        }
        
        // 2차: fmea_worksheet_data 조회 (1차에서 못 찾은 경우)
        if (legacyL2.length === 0) {
          const worksheetData = await projectPrisma.fmeaWorksheetData.findUnique({
            where: { fmeaId: fmeaIdLower },
          }).catch(() => null);
          
          if (worksheetData?.l2Data) {
            legacyL2 = worksheetData.l2Data as any[];
            console.log(`[SYNC] fmea_worksheet_data에서 ${legacyL2.length}개 공정 발견`);
          }
        }
        
        if (legacyL2.length > 0) {
          
          // 레거시 데이터를 L2Structures 형식으로 변환
          l2Structures = legacyL2.map((l2: any, idx: number) => ({
            id: l2.id || `legacy-l2-${idx}`,
            fmeaId: fmeaId,
            no: l2.no || String((idx + 1) * 10),
            name: l2.name || '',
            order: idx,
            // L3 작업요소
            l3Structures: (l2.l3 || []).map((l3: any, l3Idx: number) => {
              // ★ L3 Functions (공정특성) 추출 - 비정규화 제거: 모든 공정특성 보존
              const l3Functions: any[] = [];
              let seq = 0;
              
              // 방법 1: l3.functions 배열이 있는 경우 (함수별 공정특성 전체 저장)
              if (l3.functions && Array.isArray(l3.functions)) {
                l3.functions.forEach((fn: any, fnIdx: number) => {
                  if (fn.processChars && Array.isArray(fn.processChars) && fn.processChars.length > 0) {
                    fn.processChars.forEach((pc: any, pcIdx: number) => {
                      const name = String(pc?.name || pc?.processChar || '').trim();
                      if (!name) return;
                      l3Functions.push({
                        id: pc?.id || fn?.id || `legacy-fn-${idx}-${l3Idx}-${fnIdx}-${pcIdx}`,
                        processChar: name,
                        specialChar: pc?.specialChar || fn?.specialChar || '',
                      });
                      seq++;
                    });
                  }
                  const singlePc = String(fn?.processChar || '').trim();
                  if (singlePc) {
                    l3Functions.push({
                      id: fn?.id || `legacy-fn-${idx}-${l3Idx}-${fnIdx}-single`,
                      processChar: singlePc,
                      specialChar: fn?.specialChar || '',
                    });
                    seq++;
                  }
                });
              }
              
              // 방법 2: l3.processChars 배열이 직접 있는 경우 (직접 저장된 공정특성 전체 보존)
              if (l3.processChars && Array.isArray(l3.processChars)) {
                l3.processChars.forEach((pc: any, pcIdx: number) => {
                  const name = String(pc?.name || pc?.processChar || '').trim();
                  if (!name) return;
                  l3Functions.push({
                    id: pc?.id || `legacy-fn-${idx}-${l3Idx}-pc-${pcIdx}`,
                    processChar: name,
                    specialChar: pc?.specialChar || '',
                  });
                  seq++;
                });
              }
              
              // 방법 3: l3.l3Functions (이미 원자성 형식)
              if (l3.l3Functions && Array.isArray(l3.l3Functions)) {
                l3.l3Functions.forEach((fn: any, fnIdx: number) => {
                  const name = String(fn?.processChar || '').trim();
                  if (!name) return;
                  l3Functions.push({
                    ...fn,
                    id: fn?.id || `legacy-fn-${idx}-${l3Idx}-atomic-${fnIdx}`,
                    processChar: name,
                    specialChar: fn?.specialChar || '',
                  });
                  seq++;
                });
              }
              
              return {
                id: l3.id || `legacy-l3-${idx}-${l3Idx}`,
                name: l3.name || '',
                // ★ 4M 정규화: m4, fourM, 4m, category4M 등 다양한 필드명 지원
                m4: get4MFromL3(l3),
                order: l3Idx,
                l3Functions,
                // 원본 레거시 참고용 (디버깅)
                _legacyProcessCharCount: seq,
              };
            }),
            // L2 Functions (제품특성) - 비정규화 제거: 모든 제품특성 보존
            l2Functions: (l2.functions || []).flatMap((fn: any, fnIdx: number) => {
              const entries: any[] = [];
              if (fn.productChars && Array.isArray(fn.productChars) && fn.productChars.length > 0) {
                fn.productChars.forEach((pc: any, pcIdx: number) => {
                  const name = String(pc?.name || pc?.productChar || '').trim();
                  if (!name) return;
                  entries.push({
                    id: pc?.id || fn?.id || `legacy-l2fn-${idx}-${fnIdx}-${pcIdx}`,
                    productChar: name,
                    specialChar: pc?.specialChar || fn?.specialChar || '',
                  });
                });
              }
              const singlePc = String(fn?.productChar || '').trim();
              if (singlePc) {
                entries.push({
                  id: fn?.id || `legacy-l2fn-${idx}-${fnIdx}-single`,
                  productChar: singlePc,
                  specialChar: fn?.specialChar || '',
                });
              }
              return entries;
            }),
          }));
        }
      } catch (e: any) {
        console.warn('[SYNC] 레거시 데이터 조회 실패:', e.message);
      }
    }

    if (!l2Structures || l2Structures.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'FMEA 구조 데이터가 없습니다',
      });
    }

    // 2. CP 헤더 조회 또는 생성
    let cp;
    if (cpNo) {
      cp = await prisma.controlPlan.findUnique({
        where: { cpNo },
      });
    }

    if (!cp) {
      return NextResponse.json({
        success: false,
        error: 'CP를 찾을 수 없습니다. 먼저 CP를 생성하세요.',
      });
    }

    // 3. 기존 CP 항목 삭제 (overwrite 옵션)
    if (options?.overwrite) {
      await prisma.controlPlanItem.deleteMany({
        where: { cpId: cp.id },
      });
    }

    // 4. FMEA 구조 → CP 항목 변환 및 저장
    // ★ 2026-01-16: 원자성 데이터 구조 - 각 특성을 별도 행으로 분리, charIndex 부여
    const cpItems: any[] = [];
    let sortOrder = 0;

    for (const l2 of l2Structures) {
      // L2Function에서 제품특성 추출 (각각 별도 행)
      const l2Functions = l2.l2Functions || [];
      const productCharList = l2Functions
        .map((f: any) => ({
          name: typeof f.productChar === 'string' ? f.productChar.trim() : '',
          specialChar: f.specialChar || ''
        }))
        .filter((f: any) => f.name);
      
      // L3Structure + L3Function에서 공정특성 추출 (각각 별도 행)
      const l3Structures = l2.l3Structures || [];
      
      // ★ 설비/금형/지그 연동: MN(Man) 제외, 나머지 모두 포함
      // ★ 빈 4M 값도 설비로 포함 (4M이 설정되지 않은 경우도 설비일 수 있음)
      const equipmentL3s = l3Structures.filter((l3: any) => {
        const m4 = get4MFromL3(l3);
        const isMan = (m4 === 'MN');
        // 디버깅 로그
        console.log(`[SYNC-4M] L2=${l2.name}, L3=${l3.name}, rawM4=${l3.m4||l3.fourM||''}, normalized=${m4}, isMan=${isMan}, included=${!isMan}`);
        return !isMan; // MN(Man)만 제외, 나머지 모두 포함 (MC, IM, EN, 빈값)
      });
      const equipmentNames = equipmentL3s
        .map((l3: any) => (typeof l3.name === 'string' ? l3.name.trim() : ''))
        .filter(Boolean);
      
      console.log(`[SYNC-EQUIP] L2=${l2.name}, 설비 목록: [${equipmentNames.join(', ')}]`);
      
      // ★ 공정특성 추출 - 다양한 데이터 소스 지원
      // ★ MN(Man) 분류는 공정특성 연동에서 제외
      const processCharList: { name: string; specialChar: string }[] = [];
      const excludedProcessChars = new Set(['작업숙련도']);
      const addedProcessChars = new Set<string>(); // 중복 방지
      
      for (const l3 of l3Structures) {
        const m4 = get4MFromL3(l3);
        if (m4 === 'MN') {
          console.log(`[SYNC-PROC] L3=${l3.name} (m4=MN) 공정특성 제외`);
          continue;
        }
        // ★ 소스 1: l3.l3Functions (원자성 DB 또는 변환된 데이터)
        if (l3.l3Functions && Array.isArray(l3.l3Functions)) {
          for (const func of l3.l3Functions) {
            const processChar = typeof func.processChar === 'string' ? func.processChar.trim() : '';
            if (processChar && !excludedProcessChars.has(processChar) && !addedProcessChars.has(processChar)) {
              processCharList.push({ name: processChar, specialChar: func.specialChar || '' });
              addedProcessChars.add(processChar);
              console.log(`[SYNC-PROC-1] L3=${l3.name} (m4=${m4}), 공정특성: ${processChar} (from l3Functions)`);
            }
          }
        }
        
        // ★ 소스 2: l3.processChars (레거시 데이터 - 직접 저장된 공정특성)
        if (l3.processChars && Array.isArray(l3.processChars)) {
          for (const pc of l3.processChars) {
            const processChar = typeof pc === 'string' ? pc.trim() : (pc?.name || pc?.processChar || '').trim();
            if (processChar && !excludedProcessChars.has(processChar) && !addedProcessChars.has(processChar)) {
              processCharList.push({ name: processChar, specialChar: pc?.specialChar || '' });
              addedProcessChars.add(processChar);
              console.log(`[SYNC-PROC-2] L3=${l3.name} (m4=${m4}), 공정특성: ${processChar} (from processChars)`);
            }
          }
        }
        
        // ★ 소스 3: l3.functions[].processChars (레거시 - 함수 내 공정특성)
        if (l3.functions && Array.isArray(l3.functions)) {
          for (const func of l3.functions) {
            if (func.processChars && Array.isArray(func.processChars)) {
              for (const pc of func.processChars) {
                const processChar = typeof pc === 'string' ? pc.trim() : (pc?.name || '').trim();
                if (processChar && !excludedProcessChars.has(processChar) && !addedProcessChars.has(processChar)) {
                  processCharList.push({ name: processChar, specialChar: pc?.specialChar || '' });
                  addedProcessChars.add(processChar);
                  console.log(`[SYNC-PROC-3] L3=${l3.name} (m4=${m4}), 공정특성: ${processChar} (from functions.processChars)`);
                }
              }
            }
            // 단일 processChar 필드
            const singlePc = typeof func.processChar === 'string' ? func.processChar.trim() : '';
            if (singlePc && !excludedProcessChars.has(singlePc) && !addedProcessChars.has(singlePc)) {
              processCharList.push({ name: singlePc, specialChar: func.specialChar || '' });
              addedProcessChars.add(singlePc);
              console.log(`[SYNC-PROC-4] L3=${l3.name} (m4=${m4}), 공정특성: ${singlePc} (from functions.processChar)`);
            }
          }
        }
      }
      console.log(`[SYNC-PROC] L2=${l2.name}, 공정특성 총 ${processCharList.length}개: [${processCharList.map(p=>p.name).join(', ')}]`);
      
      // 공정설명은 첫 번째 L3 사용, 설비/금형/JIG는 비-MN L3 기반 목록 사용
      const firstL3 = l3Structures[0];
      const processDesc = typeof firstL3?.name === 'string' ? firstL3.name.trim() : '';
      const workElement = equipmentNames.join(', ');
      
      // ★ 원자성: 제품특성 각각 별도 행으로 생성
      let charIndex = 0;
      for (const pChar of productCharList) {
        cpItems.push({
          cpId: cp.id,
          processNo: l2.no || '',
          processName: l2.name || '',
          processLevel: 'Main',
          processDesc: processDesc,
          workElement: workElement,
          equipment: equipmentNames.join(', '),
          // ★ 한 셀에 하나의 제품특성만
          productChar: pChar.name,
          processChar: '',
          specialChar: pChar.specialChar,
          charIndex: charIndex++,  // 원자성 인덱스
          specTolerance: '',
          evalMethod: '',
          sampleSize: '',
          sampleFreq: '',
          controlMethod: '',
          reactionPlan: '',
          pfmeaRowUid: l2.id,
          pfmeaProcessId: l2.id,
          sortOrder: sortOrder++,
        });
      }
      
      // ★ 원자성: 공정특성 각각 별도 행으로 생성
      for (const pcChar of processCharList) {
        cpItems.push({
          cpId: cp.id,
          processNo: l2.no || '',
          processName: l2.name || '',
          processLevel: 'Main',
          processDesc: processDesc,
          workElement: workElement,
          equipment: equipmentNames.join(', '),
          productChar: '',
          // ★ 한 셀에 하나의 공정특성만
          processChar: pcChar.name,
          specialChar: pcChar.specialChar,
          charIndex: charIndex++,  // 원자성 인덱스
          specTolerance: '',
          evalMethod: '',
          sampleSize: '',
          sampleFreq: '',
          controlMethod: '',
          reactionPlan: '',
          pfmeaRowUid: l2.id,
          pfmeaProcessId: l2.id,
          sortOrder: sortOrder++,
        });
      }
      
      // ★ 제품특성/공정특성 없으면 빈 행 1개 생성
      if (productCharList.length === 0 && processCharList.length === 0) {
        cpItems.push({
          cpId: cp.id,
          processNo: l2.no || '',
          processName: l2.name || '',
          processLevel: 'Main',
          processDesc: processDesc,
          workElement: workElement,
          equipment: equipmentNames.join(', '),
          productChar: '',
          processChar: '',
          specialChar: '',
          charIndex: 0,
          specTolerance: '',
          evalMethod: '',
          sampleSize: '',
          sampleFreq: '',
          controlMethod: '',
          reactionPlan: '',
          pfmeaRowUid: l2.id,
          pfmeaProcessId: l2.id,
          sortOrder: sortOrder++,
        });
      }
    }

    // 5. 일괄 저장 (개별 create로 안정성 확보)
    for (const item of cpItems) {
      await prisma.controlPlanItem.create({
        data: {
          cpId: item.cpId,
          processNo: item.processNo,
          processName: item.processName,
          processLevel: item.processLevel,
          processDesc: item.processDesc,
          workElement: item.workElement,
          equipment: item.equipment,
          productChar: item.productChar,
          processChar: item.processChar,
          specialChar: item.specialChar,
          charIndex: item.charIndex,
          specTolerance: item.specTolerance,
          evalMethod: item.evalMethod,
          sampleSize: item.sampleSize,
          sampleFreq: item.sampleFreq,
          controlMethod: item.controlMethod,
          reactionPlan: item.reactionPlan,
          pfmeaRowUid: item.pfmeaRowUid,
          pfmeaProcessId: item.pfmeaProcessId,
          sortOrder: item.sortOrder,
        },
      });
    }

    // 6. 동기화 로그 저장
    await prisma.syncLog.create({
      data: {
        sourceType: 'fmea',
        sourceId: fmeaId,
        targetType: 'cp',
        targetId: cp.cpNo,
        action: 'create',
        status: 'synced',
        fieldChanges: JSON.stringify({ 
          itemCount: cpItems.length,
          syncedFields: ['processNo', 'processName', 'workElement', 'equipment', 'productChar', 'processChar', 'specialChar', 'charIndex']
        }),
        syncedAt: new Date(),
      },
    });

    console.log(`✅ FMEA→CP 구조 동기화 완료: ${cpItems.length}개 항목 (원자성 데이터 구조)`);

    return NextResponse.json({
      success: true,
      synced: cpItems.length,
      conflicts: [],
      skipped: 0,
      targetId: cp.cpNo,
    });

  } catch (error: any) {
    console.error('[API] FMEA→CP 동기화 실패:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
      synced: 0,
      conflicts: [],
      skipped: 0,
    });
  }
}

// ============================================================================
// CP → FMEA 구조 동기화
// ============================================================================

async function syncCpToFmea(
  prisma: any,
  cpNo: string,
  fmeaId?: string,
  data?: any,
  options?: any
): Promise<NextResponse> {
  try {
    // 1. CP 데이터 조회
    const cp = await prisma.controlPlan.findUnique({
      where: { cpNo },
      include: {
        items: {
          orderBy: { sortOrder: 'asc' },
        },
      },
    });

    if (!cp || !cp.items || cp.items.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'CP 데이터가 없습니다',
      });
    }

    // 2. FMEA 조회
    if (!fmeaId) {
      return NextResponse.json({
        success: false,
        error: 'FMEA ID가 필요합니다',
      });
    }

    const fmeaIdLower = fmeaId.toLowerCase();
    const baseUrl = getBaseDatabaseUrl();
    const schema = getProjectSchemaName(fmeaIdLower);
    let projectPrisma = prisma;

    if (baseUrl) {
      await ensureProjectSchemaReady({ baseDatabaseUrl: baseUrl, schema });
      projectPrisma = getPrismaForSchema(schema) || prisma;
      console.log(`[SYNC] CP→FMEA 프로젝트 스키마 사용: ${schema}`);
    }

    // L1 조회 (FMEA에 L1이 있어야 L2 생성 가능)
    const l1 = await projectPrisma.l1Structure.findFirst({
      where: { fmeaId: fmeaIdLower },
      orderBy: { order: 'asc' },
    });

    if (!l1) {
      return NextResponse.json({
        success: false,
        error: 'FMEA L1 구조가 없습니다. 먼저 FMEA 구조를 생성하세요.',
      });
    }

    // 3. CP 항목 → FMEA L2 구조로 변환
    // 공정번호+공정명으로 그룹화
    const processGroups = new Map<string, any[]>();
    
    cp.items.forEach((item: any) => {
      const key = `${item.processNo}_${item.processName}`;
      if (!processGroups.has(key)) {
        processGroups.set(key, []);
      }
      processGroups.get(key)!.push(item);
    });

    // 4. L2 구조 생성
    let l2Count = 0;
    
    for (const [key, items] of processGroups) {
      const firstItem = items[0];
      
      // L2 생성 (스키마에 맞게)
      const l2 = await projectPrisma.l2Structure.create({
        data: {
          fmeaId: fmeaIdLower,
          l1Id: l1.id,
          no: firstItem.processNo || String((l2Count + 1) * 10),
          name: firstItem.processName || '',
          order: l2Count,
        },
      });

      // L3 생성 (workElement가 있는 경우)
      if (firstItem.workElement) {
        await projectPrisma.l3Structure.create({
          data: {
            fmeaId: fmeaIdLower,
            l1Id: l1.id,
            l2Id: l2.id,
            name: firstItem.workElement,
            order: 0,
          },
        });
      }

      l2Count++;
    }

    // 5. 동기화 로그 저장
    await prisma.syncLog.create({
      data: {
        sourceType: 'cp',
        sourceId: cpNo,
        targetType: 'fmea',
        targetId: fmeaId,
        action: 'create',
        status: 'synced',
        fieldChanges: JSON.stringify({ l2Count }),
        syncedAt: new Date(),
      },
    });

    console.log(`✅ CP→FMEA 구조 동기화 완료: ${l2Count}개 공정`);

    return NextResponse.json({
      success: true,
      synced: l2Count,
      conflicts: [],
      skipped: 0,
      targetId: fmeaId,
    });

  } catch (error: any) {
    console.error('[API] CP→FMEA 동기화 실패:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
      synced: 0,
      conflicts: [],
      skipped: 0,
    });
  }
}

// ============================================================================
// PFD → FMEA 구조 동기화
// ============================================================================

async function syncPfdToFmea(
  prisma: any,
  pfdId: string,
  fmeaId?: string,
  options?: any
): Promise<NextResponse> {
  try {
    // 1. PFD 데이터 조회
    const pfd = await prisma.pfdRegistration.findFirst({
      where: {
        OR: [{ id: pfdId }, { pfdNo: pfdId }],
      },
      include: {
        items: {
          where: { isDeleted: false },
          orderBy: { sortOrder: 'asc' },
        },
      },
    });

    if (!pfd || !pfd.items || pfd.items.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'PFD 데이터가 없습니다',
      });
    }

    // 2. FMEA 확인 (없으면 오류)
    if (!fmeaId) {
      fmeaId = pfd.fmeaId;
    }
    
    if (!fmeaId) {
      return NextResponse.json({
        success: false,
        error: 'FMEA ID가 필요합니다',
      });
    }

    // L1 조회
    const l1 = await prisma.l1Structure.findFirst({
      where: { fmeaId },
      orderBy: { order: 'asc' },
    });

    if (!l1) {
      return NextResponse.json({
        success: false,
        error: 'FMEA L1 구조가 없습니다. 먼저 FMEA 구조를 생성하세요.',
      });
    }

    // 3. PFD 항목 → FMEA L2/L3 구조로 변환
    let l2Count = 0;
    const processGroups = new Map<string, any[]>();
    
    pfd.items.forEach((item: any) => {
      const key = `${item.processNo}_${item.processName}`;
      if (!processGroups.has(key)) {
        processGroups.set(key, []);
      }
      processGroups.get(key)!.push(item);
    });

    for (const [key, items] of processGroups) {
      const firstItem = items[0];
      
      // L2 생성
      const l2 = await prisma.l2Structure.create({
        data: {
          fmeaId: fmeaId,
          l1Id: l1.id,
          no: firstItem.processNo || String((l2Count + 1) * 10),
          name: firstItem.processName || '',
          order: l2Count,
        },
      });

      // L3 생성 (workElement가 있는 경우)
      if (firstItem.workElement) {
        await prisma.l3Structure.create({
          data: {
            fmeaId: fmeaId,
            l1Id: l1.id,
            l2Id: l2.id,
            name: firstItem.workElement,
            order: 0,
          },
        });
      }

      // PFD 항목에 FMEA 연결 정보 업데이트
      await prisma.pfdItem.update({
        where: { id: firstItem.id },
        data: { fmeaL2Id: l2.id },
      });

      l2Count++;
    }

    // 4. 문서 링크 업데이트
    await prisma.documentLink.upsert({
      where: {
        sourceType_sourceId_targetType_targetId: {
          sourceType: 'pfd',
          sourceId: pfd.id,
          targetType: 'fmea',
          targetId: fmeaId,
        },
      },
      create: {
        sourceType: 'pfd',
        sourceId: pfd.id,
        targetType: 'fmea',
        targetId: fmeaId,
        linkType: 'synced_with',
        lastSyncAt: new Date(),
      },
      update: {
        lastSyncAt: new Date(),
      },
    });

    // 5. 동기화 로그
    await prisma.syncLog.create({
      data: {
        sourceType: 'pfd',
        sourceId: pfdId,
        targetType: 'fmea',
        targetId: fmeaId,
        action: 'structure_sync',
        status: 'synced',
        fieldChanges: JSON.stringify({ l2Count }),
        syncedAt: new Date(),
      },
    });

    console.log(`✅ PFD→FMEA 구조 동기화 완료: ${l2Count}개 공정`);

    return NextResponse.json({
      success: true,
      synced: l2Count,
      conflicts: [],
      skipped: 0,
      targetId: fmeaId,
    });

  } catch (error: any) {
    console.error('[API] PFD→FMEA 동기화 실패:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
      synced: 0,
      conflicts: [],
      skipped: 0,
    });
  }
}

// ============================================================================
// FMEA → PFD 구조 동기화
// ============================================================================

async function syncFmeaToPfd(
  prisma: any,
  fmeaId: string,
  pfdId?: string,
  options?: any
): Promise<NextResponse> {
  try {
    // 1. FMEA 데이터 조회
    const l2Structures = await prisma.l2Structure.findMany({
      where: { fmeaId },
      include: { l3Structures: true },
      orderBy: { order: 'asc' },
    });

    if (!l2Structures || l2Structures.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'FMEA 구조 데이터가 없습니다',
      });
    }

    // 2. PFD 확인 또는 조회
    let pfd;
    if (pfdId) {
      pfd = await prisma.pfdRegistration.findFirst({
        where: {
          OR: [{ id: pfdId }, { pfdNo: pfdId }],
        },
      });
    }

    if (!pfd) {
      return NextResponse.json({
        success: false,
        error: 'PFD를 찾을 수 없습니다. 먼저 PFD를 생성하세요.',
      });
    }

    // 3. 기존 PFD 항목 삭제 (overwrite 옵션)
    if (options?.overwrite) {
      await prisma.pfdItem.updateMany({
        where: { pfdId: pfd.id },
        data: { isDeleted: true },
      });
    }

    // 4. FMEA 구조 → PFD 항목 변환
    const pfdItems: any[] = [];
    let sortOrder = 0;

    for (const l2 of l2Structures) {
      const firstL3 = l2.l3Structures?.[0];
      
      pfdItems.push({
        pfdId: pfd.id,
        processNo: l2.no || '',
        processName: l2.name || '',
        processDesc: firstL3?.name || '',
        workElement: firstL3?.name || '',
        equipment: '',
        productChar: '',
        processChar: '',
        specialChar: '',
        fmeaL2Id: l2.id,
        fmeaL3Id: firstL3?.id || null,
        sortOrder: sortOrder++,
        isDeleted: false,
      });
    }

    // 5. 일괄 저장
    await prisma.pfdItem.createMany({
      data: pfdItems,
    });

    // 6. 문서 링크 업데이트
    await prisma.documentLink.upsert({
      where: {
        sourceType_sourceId_targetType_targetId: {
          sourceType: 'fmea',
          sourceId: fmeaId,
          targetType: 'pfd',
          targetId: pfd.id,
        },
      },
      create: {
        sourceType: 'fmea',
        sourceId: fmeaId,
        targetType: 'pfd',
        targetId: pfd.id,
        linkType: 'synced_with',
        lastSyncAt: new Date(),
      },
      update: {
        lastSyncAt: new Date(),
      },
    });

    // 7. 동기화 로그
    await prisma.syncLog.create({
      data: {
        sourceType: 'fmea',
        sourceId: fmeaId,
        targetType: 'pfd',
        targetId: pfd.id,
        action: 'structure_sync',
        status: 'synced',
        fieldChanges: JSON.stringify({ itemCount: pfdItems.length }),
        syncedAt: new Date(),
      },
    });

    console.log(`✅ FMEA→PFD 구조 동기화 완료: ${pfdItems.length}개 항목`);

    return NextResponse.json({
      success: true,
      synced: pfdItems.length,
      conflicts: [],
      skipped: 0,
      targetId: pfd.pfdNo,
    });

  } catch (error: any) {
    console.error('[API] FMEA→PFD 동기화 실패:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
      synced: 0,
      conflicts: [],
      skipped: 0,
    });
  }
}

// ============================================================================
// PFD → CP 구조 동기화
// ============================================================================

async function syncPfdToCp(
  prisma: any,
  pfdId: string,
  cpNo?: string,
  options?: any
): Promise<NextResponse> {
  try {
    // 1. PFD 데이터 조회
    const pfd = await prisma.pfdRegistration.findFirst({
      where: {
        OR: [{ id: pfdId }, { pfdNo: pfdId }],
      },
      include: {
        items: {
          where: { isDeleted: false },
          orderBy: { sortOrder: 'asc' },
        },
      },
    });

    if (!pfd || !pfd.items || pfd.items.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'PFD 데이터가 없습니다',
      });
    }

    // 2. CP 확인
    if (!cpNo) {
      cpNo = pfd.cpNo;
    }
    
    let cp;
    if (cpNo) {
      cp = await prisma.controlPlan.findUnique({
        where: { cpNo },
      });
    }

    if (!cp) {
      return NextResponse.json({
        success: false,
        error: 'CP를 찾을 수 없습니다. 먼저 CP를 생성하세요.',
      });
    }

    // 3. 기존 CP 항목 삭제 (overwrite 옵션)
    if (options?.overwrite) {
      await prisma.controlPlanItem.deleteMany({
        where: { cpId: cp.id },
      });
    }

    // 4. PFD 항목 → CP 항목 변환 및 저장
    let sortOrder = 0;
    let itemCount = 0;

    for (const item of pfd.items) {
      await prisma.controlPlanItem.create({
        data: {
          cpId: cp.id,
          processNo: item.processNo || '',
          processName: item.processName || '',
          processLevel: 'Main',
          processDesc: item.processDesc || '',
          workElement: item.workElement || '',
          equipment: item.equipment || '',
          productChar: item.productChar || '',
          processChar: item.processChar || '',
          specialChar: item.specialChar || '',
          charIndex: sortOrder,  // 원자성 인덱스
          specTolerance: '',
          evalMethod: '',
          sampleSize: '',
          sampleFreq: '',
          controlMethod: '',
          reactionPlan: '',
          sortOrder: sortOrder++,
        },
      });
      itemCount++;
    }

    // 5. 저장 완료

    // 6. 문서 링크 업데이트
    await prisma.documentLink.upsert({
      where: {
        sourceType_sourceId_targetType_targetId: {
          sourceType: 'pfd',
          sourceId: pfd.id,
          targetType: 'cp',
          targetId: cp.id,
        },
      },
      create: {
        sourceType: 'pfd',
        sourceId: pfd.id,
        targetType: 'cp',
        targetId: cp.id,
        linkType: 'synced_with',
        lastSyncAt: new Date(),
      },
      update: {
        lastSyncAt: new Date(),
      },
    });

    // 7. 동기화 로그
    await prisma.syncLog.create({
      data: {
        sourceType: 'pfd',
        sourceId: pfdId,
        targetType: 'cp',
        targetId: cp.cpNo,
        action: 'structure_sync',
        status: 'synced',
        fieldChanges: JSON.stringify({ itemCount }),
        syncedAt: new Date(),
      },
    });

    console.log(`✅ PFD→CP 구조 동기화 완료: ${itemCount}개 항목`);

    return NextResponse.json({
      success: true,
      synced: itemCount,
      conflicts: [],
      skipped: 0,
      targetId: cp.cpNo,
    });

  } catch (error: any) {
    console.error('[API] PFD→CP 동기화 실패:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
      synced: 0,
      conflicts: [],
      skipped: 0,
    });
  }
}

// ============================================================================
// CP → PFD 구조 동기화
// ============================================================================

async function syncCpToPfd(
  prisma: any,
  cpNo: string,
  pfdId?: string,
  options?: any
): Promise<NextResponse> {
  try {
    // 1. CP 데이터 조회
    const cp = await prisma.controlPlan.findUnique({
      where: { cpNo },
      include: {
        items: {
          orderBy: { sortOrder: 'asc' },
        },
      },
    });

    if (!cp || !cp.items || cp.items.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'CP 데이터가 없습니다',
      });
    }

    // 2. PFD 확인
    let pfd;
    if (pfdId) {
      pfd = await prisma.pfdRegistration.findFirst({
        where: {
          OR: [{ id: pfdId }, { pfdNo: pfdId }],
        },
      });
    }

    if (!pfd) {
      return NextResponse.json({
        success: false,
        error: 'PFD를 찾을 수 없습니다. 먼저 PFD를 생성하세요.',
      });
    }

    // 3. 기존 PFD 항목 삭제 (overwrite 옵션)
    if (options?.overwrite) {
      await prisma.pfdItem.updateMany({
        where: { pfdId: pfd.id },
        data: { isDeleted: true },
      });
    }

    // 4. CP 항목 → PFD 항목 변환
    const pfdItems: any[] = [];
    let sortOrder = 0;

    for (const item of cp.items) {
      pfdItems.push({
        pfdId: pfd.id,
        processNo: item.processNo || '',
        processName: item.processName || '',
        processDesc: item.processDesc || '',
        workElement: item.workElement || '',
        equipment: item.equipment || '',
        productChar: item.productChar || '',
        processChar: item.processChar || '',
        specialChar: item.specialChar || '',
        cpItemId: item.id,
        sortOrder: sortOrder++,
        isDeleted: false,
      });
    }

    // 5. 일괄 저장
    await prisma.pfdItem.createMany({
      data: pfdItems,
    });

    // 6. 문서 링크 업데이트
    await prisma.documentLink.upsert({
      where: {
        sourceType_sourceId_targetType_targetId: {
          sourceType: 'cp',
          sourceId: cp.id,
          targetType: 'pfd',
          targetId: pfd.id,
        },
      },
      create: {
        sourceType: 'cp',
        sourceId: cp.id,
        targetType: 'pfd',
        targetId: pfd.id,
        linkType: 'synced_with',
        lastSyncAt: new Date(),
      },
      update: {
        lastSyncAt: new Date(),
      },
    });

    // 7. 동기화 로그
    await prisma.syncLog.create({
      data: {
        sourceType: 'cp',
        sourceId: cpNo,
        targetType: 'pfd',
        targetId: pfd.pfdNo,
        action: 'structure_sync',
        status: 'synced',
        fieldChanges: JSON.stringify({ itemCount: pfdItems.length }),
        syncedAt: new Date(),
      },
    });

    console.log(`✅ CP→PFD 구조 동기화 완료: ${pfdItems.length}개 항목`);

    return NextResponse.json({
      success: true,
      synced: pfdItems.length,
      conflicts: [],
      skipped: 0,
      targetId: pfd.pfdNo,
    });

  } catch (error: any) {
    console.error('[API] CP→PFD 동기화 실패:', error);
    return NextResponse.json({
      success: false,
      error: error.message,
      synced: 0,
      conflicts: [],
      skipped: 0,
    });
  }
}
